ca65 V2.19 - Git b993d8833
Main file   : title/boot-greated.asm
Current file: title/boot-greated.asm

000000r 1               ; # GreatEd Startup code
000000r 1               ;
000000r 1               ; This is used for hacks made with greated
000000r 1               ;
000000r 1               
000000r 1               .segment "PRACTISE_PRG0"
000000r 1               TitleReset2:
000000r 1  A9 80            lda #%10000000     ; enable battery backed wram
000002r 1  8D 01 A0         sta $A001          ;
000005r 1               ; include title file
000005r 1               .include "title.asm"
000005r 2               ; # Main menu screen code
000005r 2               ;
000005r 2               ; This contains all the code used for the practise rom.
000005r 2               ;
000005r 2               ; It is included from the "boot" files.
000005r 2               ;
000005r 2               
000005r 2               .p02
000005r 2               .linecont +
000005r 2               .include "ascii.asm"
000005r 3               ; tell cc65 to convert ascii into smb1 charset
000005r 3               
000005r 3               ; space
000005r 3               .charmap    $20,   $24
000005r 3               ; !
000005r 3               .charmap    $21,   $2B
000005r 3               ; -
000005r 3               .charmap    $2D,   $28
000005r 3               ; x to cross
000005r 3               .charmap    $78,   $29
000005r 3               ; c to copyright
000005r 3               .charmap    $62,   $CF
000005r 3               ; m to mushroom
000005r 3               .charmap    $6D,   $CE
000005r 3               ; / to chain
000005r 3               .charmap    $2F,   $7F
000005r 3               
000005r 3               
000005r 3               ; 0
000005r 3               .charmap $30+00,   $00
000005r 3               ; 1
000005r 3               .charmap $30+01,   $01
000005r 3               ; 2
000005r 3               .charmap $30+02,   $02
000005r 3               ; 3
000005r 3               .charmap $30+03,   $03
000005r 3               ; 4
000005r 3               .charmap $30+04,   $04
000005r 3               ; 5
000005r 3               .charmap $30+05,   $05
000005r 3               ; 6
000005r 3               .charmap $30+06,   $06
000005r 3               ; 7
000005r 3               .charmap $30+07,   $07
000005r 3               ; 8
000005r 3               .charmap $30+08,   $08
000005r 3               ; 9
000005r 3               .charmap $30+09,   $09
000005r 3               
000005r 3               ; A
000005r 3               .charmap $41+00, $A+00
000005r 3               ; B
000005r 3               .charmap $41+01, $A+01
000005r 3               ; C
000005r 3               .charmap $41+02, $A+02
000005r 3               ; D
000005r 3               .charmap $41+03, $A+03
000005r 3               ; E
000005r 3               .charmap $41+04, $A+04
000005r 3               ; F
000005r 3               .charmap $41+05, $A+05
000005r 3               ; G
000005r 3               .charmap $41+06, $A+06
000005r 3               ; H
000005r 3               .charmap $41+07, $A+07
000005r 3               ; I
000005r 3               .charmap $41+08, $A+08
000005r 3               ; J
000005r 3               .charmap $41+09, $A+09
000005r 3               ; K
000005r 3               .charmap $41+10, $A+10
000005r 3               ; L
000005r 3               .charmap $41+11, $A+11
000005r 3               ; M
000005r 3               .charmap $41+12, $A+12
000005r 3               ; N
000005r 3               .charmap $41+13, $A+13
000005r 3               ; O
000005r 3               .charmap $41+14, $A+14
000005r 3               ; P
000005r 3               .charmap $41+15, $A+15
000005r 3               ; Q
000005r 3               .charmap $41+16, $A+16
000005r 3               ; R
000005r 3               .charmap $41+17, $A+17
000005r 3               ; S
000005r 3               .charmap $41+18, $A+18
000005r 3               ; T
000005r 3               .charmap $41+19, $A+19
000005r 3               ; U
000005r 3               .charmap $41+20, $A+20
000005r 3               ; V
000005r 3               .charmap $41+21, $A+21
000005r 3               ; W
000005r 3               .charmap $41+22, $A+22
000005r 3               ; X
000005r 3               .charmap $41+23, $A+23
000005r 3               ; Y
000005r 3               .charmap $41+24, $A+24
000005r 3               ; Z
000005r 3               .charmap $41+25, $A+25
000005r 3               
000005r 2               .include "../defines.inc"
000005r 3               
000005r 3               ;-------------------------------------------------------------------------------------
000005r 3               ;DEFINES
000005r 3               
000005r 3               ;NES specific hardware defines
000005r 3               
000005r 3               PPU_CTRL              = $2000
000005r 3               PPU_CTRL_REG1         = $2000
000005r 3               PPU_MASK              = $2001
000005r 3               PPU_CTRL_REG2         = $2001
000005r 3               PPU_STATUS            = $2002
000005r 3               PPU_SPR_ADDR          = $2003
000005r 3               PPU_SPR_DATA          = $2004
000005r 3               PPU_SCROLL            = $2005
000005r 3               PPU_SCROLL_REG        = $2005
000005r 3               PPU_ADDRESS           = $2006
000005r 3               PPU_DATA              = $2007
000005r 3               
000005r 3               SND_REGISTER          = $4000
000005r 3               SND_SQUARE1_REG       = $4000
000005r 3               SND_SQUARE2_REG       = $4004
000005r 3               SND_TRIANGLE_REG      = $4008
000005r 3               SND_NOISE_REG         = $400c
000005r 3               SND_DELTA_REG         = $4010
000005r 3               SND_MASTERCTRL_REG    = $4015
000005r 3               
000005r 3               SPR_DMA               = $4014
000005r 3               JOYPAD_PORT           = $4016
000005r 3               JOYPAD_PORT1          = $4016
000005r 3               JOYPAD_PORT2          = $4017
000005r 3               
000005r 3               ; GAME SPECIFIC DEFINES
000005r 3               
000005r 3               ObjectOffset          = $08
000005r 3               
000005r 3               FrameCounter          = $09
000005r 3               
000005r 3               SavedJoypadBits       = $06fc
000005r 3               SavedJoypad1Bits      = $06fc
000005r 3               SavedJoypad2Bits      = $06fd
000005r 3               JoypadBitMask         = $074a
000005r 3               JoypadOverride        = $0758
000005r 3               
000005r 3               A_B_Buttons           = $0a
000005r 3               PreviousA_B_Buttons   = $0d
000005r 3               Up_Down_Buttons       = $0b
000005r 3               Left_Right_Buttons    = $0c
000005r 3               
000005r 3               GameEngineSubroutine  = $0e
000005r 3               
000005r 3               Mirror_PPU_CTRL       = $0778
000005r 3               Mirror_PPU_CTRL_REG1  = $0778
000005r 3               Mirror_PPU_MASK       = $0779
000005r 3               Mirror_PPU_CTRL_REG2  = $0779
000005r 3               Mirror_FDS_CTRL_REG   = $fa
000005r 3               NameTableSelect       = $077a
000005r 3               FileListNumber        = $07f7
000005r 3               
000005r 3               OperMode              = $0770
000005r 3               OperMode_Task         = $0772
000005r 3               ScreenRoutineTask     = $073c
000005r 3               
000005r 3               DiskIOTask            = $07fc
000005r 3               NotColdFlag           = $07fd
000005r 3               
000005r 3               GamePauseStatus       = $0776
000005r 3               GamePauseTimer        = $0777
000005r 3               
000005r 3               DemoAction            = $0717
000005r 3               DemoActionTimer       = $0718
000005r 3               
000005r 3               TimerControl          = $0747
000005r 3               IntervalTimerControl  = $077f
000005r 3               
000005r 3               Timers                = $0780
000005r 3               SelectTimer           = $0780
000005r 3               PlayerAnimTimer       = $0781
000005r 3               JumpSwimTimer         = $0782
000005r 3               RunningTimer          = $0783
000005r 3               BlockBounceTimer      = $0784
000005r 3               SideCollisionTimer    = $0785
000005r 3               JumpspringTimer       = $0786
000005r 3               GameTimerCtrlTimer    = $0787
000005r 3               ClimbSideTimer        = $0789
000005r 3               EnemyFrameTimer       = $078a
000005r 3               FrenzyEnemyTimer      = $078f
000005r 3               BowserFireBreathTimer = $0790
000005r 3               StompTimer            = $0791
000005r 3               AirBubbleTimer        = $0792
000005r 3               ScrollIntervalTimer   = $0795
000005r 3               EnemyIntervalTimer    = $0796
000005r 3               BrickCoinTimer        = $079d
000005r 3               InjuryTimer           = $079e
000005r 3               StarInvincibleTimer   = $079f
000005r 3               ScreenTimer           = $07a0
000005r 3               WorldEndTimer         = $07a1
000005r 3               DemoTimer             = $07a2
000005r 3               GameOverMsgFlag       = $07f5
000005r 3               
000005r 3               SpriteLen = $4
000005r 3               Sprite_Data           = $0200
000005r 3               Sprite_Y_Position     = $0200
000005r 3               Sprite_Tilenumber     = $0201
000005r 3               Sprite_Attributes     = $0202
000005r 3               Sprite_X_Position     = $0203
000005r 3               
000005r 3               ScreenEdge_PageLoc    = $071a
000005r 3               ScreenEdge_X_Pos      = $071c
000005r 3               ScreenLeft_PageLoc    = $071a
000005r 3               ScreenRight_PageLoc   = $071b
000005r 3               ScreenLeft_X_Pos      = $071c
000005r 3               ScreenRight_X_Pos     = $071d
000005r 3               
000005r 3               PlayerFacingDir       = $33
000005r 3               DestinationPageLoc    = $34
000005r 3               VictoryWalkControl    = $35
000005r 3               ScrollFractional      = $0768
000005r 3               SecondaryMsgCounter   = $0749
000005r 3               MsgCounter            = $0719
000005r 3               MsgFractional         = $0749
000005r 3               
000005r 3               EndControlCntr        = $0761
000005r 3               BlueColorOfs          = $0762
000005r 3               BlueDelayFlag         = $0763
000005r 3               MushroomRetDelay      = $0764
000005r 3               MRetainerOffset       = $0762
000005r 3               CurrentFlashMRet      = $0763
000005r 3               
000005r 3               HorizontalScroll      = $073f
000005r 3               VerticalScroll        = $0740
000005r 3               ScrollLock            = $0723
000005r 3               ScrollThirtyTwo       = $073d
000005r 3               Player_X_Scroll       = $06ff
000005r 3               Player_Pos_ForScroll  = $0755
000005r 3               ScrollAmount          = $0775
000005r 3               
000005r 3               AreaData              = $e7
000005r 3               AreaDataLow           = $e7
000005r 3               AreaDataHigh          = $e8
000005r 3               EnemyData             = $e9
000005r 3               EnemyDataLow          = $e9
000005r 3               EnemyDataHigh         = $ea
000005r 3               AreaDataCopy          = $6010
000005r 3               EnemyDataCopy         = $6110
000005r 3               
000005r 3               AreaParserTaskNum     = $071f
000005r 3               ColumnSets            = $071e
000005r 3               CurrentPageLoc        = $0725
000005r 3               CurrentColumnPos      = $0726
000005r 3               BackloadingFlag       = $0728
000005r 3               BehindAreaParserFlag  = $0729
000005r 3               AreaObjectPageLoc     = $072a
000005r 3               AreaObjectPageSel     = $072b
000005r 3               AreaDataOffset        = $072c
000005r 3               AreaObjOffsetBuffer   = $072d
000005r 3               AreaObjectLength      = $0730
000005r 3               StaircaseControl      = $0734
000005r 3               AreaObjectHeight      = $0735
000005r 3               MushroomLedgeHalfLen  = $0736
000005r 3               EnemyDataOffset       = $0739
000005r 3               EnemyObjectPageLoc    = $073a
000005r 3               EnemyObjectPageSel    = $073b
000005r 3               MetatileBuffer        = $06a1
000005r 3               BlockBufferColumnPos  = $06a0
000005r 3               CurrentNTAddr_Low     = $0721
000005r 3               CurrentNTAddr_High    = $0720
000005r 3               AttributeBuffer       = $03f9
000005r 3               
000005r 3               LoopCommand           = $0745
000005r 3               
000005r 3               DisplayDigits         = $07d7
000005r 3               TopScoreDisplay       = $07d7
000005r 3               ScoreAndCoinDisplay   = $07dd
000005r 3               PlayerScoreDisplay    = $07dd
000005r 3               GameTimerDisplay      = $07ec
000005r 3               CoinDisplay           = $07e7
000005r 3               DigitModifier         = $0134
000005r 3               
000005r 3               VerticalFlipFlag      = $0109
000005r 3               FloateyNum_Control    = $0110
000005r 3               ShellChainCounter     = $0125
000005r 3               FloateyNum_Timer      = $012c
000005r 3               FloateyNum_X_Pos      = $0117
000005r 3               FloateyNum_Y_Pos      = $011e
000005r 3               FlagpoleFNum_Y_Pos    = $010d
000005r 3               FlagpoleFNum_YMFDummy = $010e
000005r 3               FlagpoleScore         = $010f
000005r 3               FlagpoleCollisionYPos = $070f
000005r 3               StompChainCounter     = $0484
000005r 3               FlagpoleMusicFlag     = $07f6
000005r 3               
000005r 3               VRAM_Buffer1_Offset   = $0300
000005r 3               VRAM_Buffer1          = $0301
000005r 3               VRAM_Buffer2_Offset   = $0340
000005r 3               VRAM_Buffer2          = $0341
000005r 3               VRAM_Buffer_AddrCtrl  = $0773
000005r 3               IRQAckFlag			  = $077b
000005r 3               IRQUpdateFlag  		  = $0722
000005r 3               DisableScreenFlag     = $0774
000005r 3               DisableIntermediate   = $0769
000005r 3               ColorRotateOffset     = $06d4
000005r 3               
000005r 3               TerrainControl        = $0727
000005r 3               AreaStyle             = $0733
000005r 3               ForegroundScenery     = $0741
000005r 3               BackgroundScenery     = $0742
000005r 3               CloudTypeOverride     = $0743
000005r 3               BackgroundColorCtrl   = $0744
000005r 3               AreaType              = $074e
000005r 3               AreaAddrsLOffset      = $074f
000005r 3               AreaPointer           = $0750
000005r 3               
000005r 3               PlayerEntranceCtrl    = $0710
000005r 3               GameTimerSetting      = $0715
000005r 3               AltEntranceControl    = $0752
000005r 3               EntrancePage          = $0751
000005r 3               WarpZoneControl       = $06d6
000005r 3               ChangeAreaTimer       = $06de
000005r 3               
000005r 3               MultiLoopCorrectCntr  = $06d9
000005r 3               MultiLoopPassCntr     = $06da
000005r 3               
000005r 3               FetchNewGameTimerFlag = $0757
000005r 3               GameTimerExpiredFlag  = $0759
000005r 3               
000005r 3               PrimaryHardMode       = $076a
000005r 3               SecondaryHardMode     = $06cc
000005r 3               WorldSelectNumber     = $076b
000005r 3               CompletedWorlds       = $07fa
000005r 3               HardWorldFlag         = $07fb
000005r 3               ContinueMenuSelect    = $07f8
000005r 3               
000005r 3               SelectedPlayer        = $0753
000005r 3               PlayerSize            = $0754
000005r 3               PlayerStatus          = $0756
000005r 3               
000005r 3               OnscreenPlayerInfo    = $075a
000005r 3               NumberofLives         = $075a ;used by current player
000005r 3               HalfwayPage           = $075b
000005r 3               LevelNumber           = $075c ;the actual dash number
000005r 3               Hidden1UpFlag         = $075d
000005r 3               CoinTally             = $075e
000005r 3               WorldNumber           = $075f
000005r 3               AreaNumber            = $0760 ;internal number used to find areas
000005r 3               
000005r 3               CoinTallyFor1Ups      = $0748
000005r 3               
000005r 3               BalPlatformAlignment  = $03a0
000005r 3               Platform_X_Scroll     = $03a1
000005r 3               PlatformCollisionFlag = $03a2
000005r 3               YPlatformTopYPos      = $0401
000005r 3               YPlatformCenterYPos   = $58
000005r 3               
000005r 3               BrickCoinTimerFlag    = $06bc
000005r 3               StarFlagTaskControl   = $0746
000005r 3               
000005r 3               PseudoRandomBitReg    = $07a7
000005r 3               WarmBootValidation    = $07ff
000005r 3               
000005r 3               SprShuffleAmtOffset   = $06e0
000005r 3               SprShuffleAmt         = $06e1
000005r 3               SprDataOffset         = $06e4
000005r 3               Player_SprDataOffset  = $06e4
000005r 3               Enemy_SprDataOffset   = $06e5
000005r 3               Block_SprDataOffset   = $06ec
000005r 3               Alt_SprDataOffset     = $06ec
000005r 3               Bubble_SprDataOffset  = $06ee
000005r 3               FBall_SprDataOffset   = $06f1
000005r 3               Misc_SprDataOffset    = $06f3
000005r 3               SprDataOffset_Ctrl    = $03ee
000005r 3               
000005r 3               Player_State          = $1d
000005r 3               Enemy_State           = $1e
000005r 3               Fireball_State        = $24
000005r 3               Block_State           = $26
000005r 3               Misc_State            = $2a
000005r 3               
000005r 3               Player_MovingDir      = $45
000005r 3               Enemy_MovingDir       = $46
000005r 3               
000005r 3               SprObject_X_Speed     = $57
000005r 3               Player_X_Speed        = $57
000005r 3               Enemy_X_Speed         = $58
000005r 3               Fireball_X_Speed      = $5e
000005r 3               Block_X_Speed         = $60
000005r 3               Misc_X_Speed          = $64
000005r 3               
000005r 3               Jumpspring_FixedYPos  = $58
000005r 3               JumpspringAnimCtrl    = $070e
000005r 3               JumpspringForce       = $06db
000005r 3               
000005r 3               SprObject_PageLoc     = $6d
000005r 3               Player_PageLoc        = $6d
000005r 3               Enemy_PageLoc         = $6e
000005r 3               Fireball_PageLoc      = $74
000005r 3               Block_PageLoc         = $76
000005r 3               Misc_PageLoc          = $7a
000005r 3               Bubble_PageLoc        = $83
000005r 3               
000005r 3               SprObject_X_Position  = $86
000005r 3               Player_X_Position     = $86
000005r 3               Enemy_X_Position      = $87
000005r 3               Fireball_X_Position   = $8d
000005r 3               Block_X_Position      = $8f
000005r 3               Misc_X_Position       = $93
000005r 3               Bubble_X_Position     = $9c
000005r 3               
000005r 3               SprObject_Y_Speed     = $9f
000005r 3               Player_Y_Speed        = $9f
000005r 3               Enemy_Y_Speed         = $a0
000005r 3               Fireball_Y_Speed      = $a6
000005r 3               Block_Y_Speed         = $a8
000005r 3               Misc_Y_Speed          = $ac
000005r 3               
000005r 3               SprObject_Y_HighPos   = $b5
000005r 3               Player_Y_HighPos      = $b5
000005r 3               Enemy_Y_HighPos       = $b6
000005r 3               Fireball_Y_HighPos    = $bc
000005r 3               Block_Y_HighPos       = $be
000005r 3               Misc_Y_HighPos        = $c2
000005r 3               Bubble_Y_HighPos      = $cb
000005r 3               
000005r 3               SprObject_Y_Position  = $ce
000005r 3               Player_Y_Position     = $ce
000005r 3               Enemy_Y_Position      = $cf
000005r 3               Fireball_Y_Position   = $d5
000005r 3               Block_Y_Position      = $d7
000005r 3               Misc_Y_Position       = $db
000005r 3               Bubble_Y_Position     = $e4
000005r 3               
000005r 3               SprObject_Rel_XPos    = $03ad
000005r 3               Player_Rel_XPos       = $03ad
000005r 3               Enemy_Rel_XPos        = $03ae
000005r 3               Fireball_Rel_XPos     = $03af
000005r 3               Bubble_Rel_XPos       = $03b0
000005r 3               Block_Rel_XPos        = $03b1
000005r 3               Misc_Rel_XPos         = $03b3
000005r 3               
000005r 3               SprObject_Rel_YPos    = $03b8
000005r 3               Player_Rel_YPos       = $03b8
000005r 3               Enemy_Rel_YPos        = $03b9
000005r 3               Fireball_Rel_YPos     = $03ba
000005r 3               Bubble_Rel_YPos       = $03bb
000005r 3               Block_Rel_YPos        = $03bc
000005r 3               Misc_Rel_YPos         = $03be
000005r 3               
000005r 3               SprObject_SprAttrib   = $03c4
000005r 3               Player_SprAttrib      = $03c4
000005r 3               Enemy_SprAttrib       = $03c5
000005r 3               
000005r 3               SprObject_X_MoveForce = $0400
000005r 3               Enemy_X_MoveForce     = $0401
000005r 3               
000005r 3               SprObject_YMF_Dummy   = $0416
000005r 3               Player_YMF_Dummy      = $0416
000005r 3               Enemy_YMF_Dummy       = $0417
000005r 3               Bubble_YMF_Dummy      = $042c
000005r 3               
000005r 3               SprObject_Y_MoveForce = $0433
000005r 3               Player_Y_MoveForce    = $0433
000005r 3               Enemy_Y_MoveForce     = $0434
000005r 3               Block_Y_MoveForce     = $043c
000005r 3               
000005r 3               DisableCollisionDet   = $0716
000005r 3               Player_CollisionBits  = $0490
000005r 3               Enemy_CollisionBits   = $0491
000005r 3               
000005r 3               SprObj_BoundBoxCtrl   = $0499
000005r 3               Player_BoundBoxCtrl   = $0499
000005r 3               Enemy_BoundBoxCtrl    = $049a
000005r 3               Fireball_BoundBoxCtrl = $04a0
000005r 3               Misc_BoundBoxCtrl     = $04a2
000005r 3               
000005r 3               EnemyFrenzyBuffer     = $06cb
000005r 3               EnemyFrenzyQueue      = $06cd
000005r 3               Enemy_Flag            = $0f
000005r 3               Enemy_ID              = $16
000005r 3               
000005r 3               PlayerGfxOffset       = $06d5
000005r 3               Player_XSpeedAbsolute = $0700
000005r 3               FrictionAdderHigh     = $0701
000005r 3               FrictionAdderLow      = $0702
000005r 3               RunningSpeed          = $0703
000005r 3               SwimmingFlag          = $0704
000005r 3               Player_X_MoveForce    = $0705
000005r 3               DiffToHaltJump        = $0706
000005r 3               JumpOrigin_Y_HighPos  = $0707
000005r 3               JumpOrigin_Y_Position = $0708
000005r 3               VerticalForce         = $0709
000005r 3               VerticalForceDown     = $070a
000005r 3               PlayerChangeSizeFlag  = $070b
000005r 3               PlayerAnimTimerSet    = $070c
000005r 3               PlayerAnimCtrl        = $070d
000005r 3               DeathMusicLoaded      = $0712
000005r 3               FlagpoleSoundQueue    = $0713
000005r 3               CrouchingFlag         = $0714
000005r 3               MaximumLeftSpeed      = $0450
000005r 3               MaximumRightSpeed     = $0456
000005r 3               
000005r 3               WindFlag              = $07f9
000005r 3               
000005r 3               SprObject_OffscrBits  = $03d0
000005r 3               Player_OffscreenBits  = $03d0
000005r 3               Enemy_OffscreenBits   = $03d1
000005r 3               FBall_OffscreenBits   = $03d2
000005r 3               Bubble_OffscreenBits  = $03d3
000005r 3               Block_OffscreenBits   = $03d4
000005r 3               Misc_OffscreenBits    = $03d6
000005r 3               EnemyOffscrBitsMasked = $03d8
000005r 3               
000005r 3               Cannon_Offset         = $046a
000005r 3               Cannon_PageLoc        = $046b
000005r 3               Cannon_X_Position     = $0471
000005r 3               Cannon_Y_Position     = $0477
000005r 3               Cannon_Timer          = $047d
000005r 3               
000005r 3               Whirlpool_Offset      = $046a
000005r 3               Whirlpool_PageLoc     = $046b
000005r 3               Whirlpool_LeftExtent  = $0471
000005r 3               Whirlpool_Length      = $0477
000005r 3               Whirlpool_Flag        = $047d
000005r 3               
000005r 3               VineFlagOffset        = $0398
000005r 3               VineHeight            = $0399
000005r 3               VineObjOffset         = $039a
000005r 3               VineStart_Y_Position  = $039d
000005r 3               
000005r 3               Block_Orig_YPos       = $03e4
000005r 3               Block_BBuf_Low        = $03e6
000005r 3               Block_Metatile        = $03e8
000005r 3               Block_PageLoc2        = $03ea
000005r 3               Block_RepFlag         = $03ec
000005r 3               Block_ResidualCounter = $03f0
000005r 3               Block_Orig_XPos       = $03f1
000005r 3               
000005r 3               BoundingBox_UL_XPos   = $04ac
000005r 3               BoundingBox_UL_YPos   = $04ad
000005r 3               BoundingBox_DR_XPos   = $04ae
000005r 3               BoundingBox_DR_YPos   = $04af
000005r 3               BoundingBox_UL_Corner = $04ac
000005r 3               BoundingBox_LR_Corner = $04ae
000005r 3               EnemyBoundingBoxCoord = $04b0
000005r 3               
000005r 3               PowerUpType           = $39
000005r 3               
000005r 3               FireballBouncingFlag  = $3a
000005r 3               FireballCounter       = $06ce
000005r 3               FireballThrowingTimer = $0711
000005r 3               
000005r 3               HammerEnemyOffset     = $06ae
000005r 3               JumpCoinMiscOffset    = $06b7
000005r 3               
000005r 3               Block_Buffer_1        = $0500
000005r 3               Block_Buffer_2        = $05d0
000005r 3               
000005r 3               HammerThrowingTimer   = $03a2
000005r 3               HammerBroJumpTimer    = $3c
000005r 3               Misc_Collision_Flag   = $06be
000005r 3               
000005r 3               RedPTroopaOrigXPos    = $0401
000005r 3               RedPTroopaCenterYPos  = $58
000005r 3               
000005r 3               XMovePrimaryCounter   = $a0
000005r 3               XMoveSecondaryCounter = $58
000005r 3               
000005r 3               CheepCheepMoveMFlag   = $58
000005r 3               CheepCheepOrigYPos    = $0434
000005r 3               BitMFilter            = $06dd
000005r 3               
000005r 3               LakituReappearTimer   = $06d1
000005r 3               LakituMoveSpeed       = $58
000005r 3               LakituMoveDirection   = $a0
000005r 3               
000005r 3               FirebarSpinState_Low  = $58
000005r 3               FirebarSpinState_High = $a0
000005r 3               FirebarSpinSpeed      = $0388
000005r 3               FirebarSpinDirection  = $34
000005r 3               
000005r 3               DuplicateObj_Offset   = $06cf
000005r 3               NumberofGroupEnemies  = $06d3
000005r 3               
000005r 3               BlooperMoveCounter    = $a0
000005r 3               BlooperMoveSpeed      = $58
000005r 3               
000005r 3               BowserBodyControls    = $0363
000005r 3               BowserFeetCounter     = $0364
000005r 3               BowserMovementSpeed   = $0365
000005r 3               BowserOrigXPos        = $0366
000005r 3               BowserFlameTimerCtrl  = $0367
000005r 3               BowserFront_Offset    = $0368
000005r 3               BridgeCollapseOffset  = $0369
000005r 3               BowserGfxFlag         = $036a
000005r 3               BowserHitPoints       = $0483
000005r 3               MaxRangeFromOrigin    = $06dc
000005r 3               
000005r 3               BowserFlamePRandomOfs = $0417
000005r 3               
000005r 3               PiranhaPlantUpYPos    = $0417
000005r 3               PiranhaPlantDownYPos  = $0434
000005r 3               PiranhaPlant_Y_Speed  = $58
000005r 3               PiranhaPlant_MoveFlag = $a0
000005r 3               
000005r 3               FireworksCounter      = $06d7
000005r 3               ExplosionGfxCounter   = $58
000005r 3               ExplosionTimerCounter = $a0
000005r 3               
000005r 3               LeavesXPosCopy        = $6210
000005r 3               LeavesYPosCopy        = $621c
000005r 3               
000005r 3               SaveDataHeader        = $6000
000005r 3               GamesBeatenCount      = $6007
000005r 3               ContinueWorld         = $6008
000005r 3               SavedHardWorldFlag    = $6009
000005r 3               SavedCompletedWorlds  = $600a
000005r 3               
000005r 3               IncrementRNG_122      = $600b
000005r 3               
000005r 3               ;sound related defines
000005r 3               Squ2_NoteLenBuffer    = $07b3
000005r 3               Squ2_NoteLenCounter   = $07b4
000005r 3               Squ2_EnvelopeDataCtrl = $07b5
000005r 3               Squ1_NoteLenCounter   = $07b6
000005r 3               Squ1_EnvelopeDataCtrl = $07b7
000005r 3               Tri_NoteLenBuffer     = $07b8
000005r 3               Tri_NoteLenCounter    = $07b9
000005r 3               Noise_BeatLenCounter  = $07ba
000005r 3               Squ1_SfxLenCounter    = $07bb
000005r 3               Squ2_SfxLenCounter    = $07bd
000005r 3               Sfx_SecondaryCounter  = $07be
000005r 3               Noise_SfxLenCounter   = $07bf
000005r 3               
000005r 3               PauseSoundQueue       = $fa
000005r 3               Square1SoundQueue     = $ff
000005r 3               Square2SoundQueue     = $fe
000005r 3               NoiseSoundQueue       = $fd
000005r 3               AreaMusicQueue        = $fb
000005r 3               EventMusicQueue       = $fc
000005r 3               
000005r 3               Square1SoundBuffer    = $f1
000005r 3               Square2SoundBuffer    = $f2
000005r 3               NoiseSoundBuffer      = $f3
000005r 3               AreaMusicBuffer       = $f4
000005r 3               EventMusicBuffer      = $07b1
000005r 3               PauseSoundBuffer      = $07b2
000005r 3               
000005r 3               PatternNumber         = $061d
000005r 3               
000005r 3               MusicData             = $f5
000005r 3               MusicDataLow          = $f5
000005r 3               MusicDataHigh         = $f6
000005r 3               MusicOffset_Square2   = $f7
000005r 3               MusicOffset_Square1   = $f8
000005r 3               MusicOffset_Triangle  = $f9
000005r 3               MusicOffset_Noise     = $07b0
000005r 3               
000005r 3               NoteLenLookupTblOfs   = $f0
000005r 3               DAC_Counter           = $07c0
000005r 3               NoiseDataLoopbackOfs  = $07c1
000005r 3               NoteLengthTblAdder    = $07c4
000005r 3               AreaMusicBuffer_Alt   = $07c5
000005r 3               PauseModeFlag         = $07c6
000005r 3               GroundMusicHeaderOfs  = $07c7
000005r 3               AltRegContentFlag     = $07ca
000005r 3               
000005r 3               ;-------------------------------------------------------------------------------------
000005r 3               ;CONSTANTS
000005r 3               
000005r 3               ;sound effects constants
000005r 3               Sfx_SmallJump         = %10000000
000005r 3               Sfx_Flagpole          = %01000000
000005r 3               Sfx_Fireball          = %00100000
000005r 3               Sfx_PipeDown_Injury   = %00010000
000005r 3               Sfx_EnemySmack        = %00001000
000005r 3               Sfx_EnemyStomp        = %00000100
000005r 3               Sfx_Bump              = %00000010
000005r 3               Sfx_BigJump           = %00000001
000005r 3               
000005r 3               Sfx_BowserFall        = %10000000
000005r 3               Sfx_ExtraLife         = %01000000
000005r 3               Sfx_PowerUpGrab       = %00100000
000005r 3               Sfx_TimerTick         = %00010000
000005r 3               Sfx_Blast             = %00001000
000005r 3               Sfx_GrowVine          = %00000100
000005r 3               Sfx_GrowPowerUp       = %00000010
000005r 3               Sfx_CoinGrab          = %00000001
000005r 3               
000005r 3               Sfx_BowserFlame       = %00000010
000005r 3               Sfx_BrickShatter      = %00000001
000005r 3               
000005r 3               ;music constants
000005r 3               Silence               = %10000000
000005r 3               
000005r 3               StarPowerMusic        = %01000000
000005r 3               PipeIntroMusic        = %00100000
000005r 3               CloudMusic            = %00010000
000005r 3               CastleMusic           = %00001000
000005r 3               UndergroundMusic      = %00000100
000005r 3               WaterMusic            = %00000010
000005r 3               GroundMusic           = %00000001
000005r 3               
000005r 3               TimeRunningOutMusic   = %01000000
000005r 3               EndOfLevelMusic       = %00100000
000005r 3               AltGameOverMusic      = %00010000
000005r 3               EndOfCastleMusic      = %00001000
000005r 3               VictoryMusic          = %00000100
000005r 3               GameOverMusic         = %00000010
000005r 3               DeathMusic            = %00000001
000005r 3               
000005r 3               ;enemy object constants
000005r 3               GreenKoopa            = $00
000005r 3               BuzzyBeetle           = $02
000005r 3               RedKoopa              = $03
000005r 3               HammerBro             = $05
000005r 3               Goomba                = $06
000005r 3               Bloober               = $07
000005r 3               BulletBill_FrenzyVar  = $08
000005r 3               GreyCheepCheep        = $0a
000005r 3               RedCheepCheep         = $0b
000005r 3               Podoboo               = $0c
000005r 3               PiranhaPlant          = $0d
000005r 3               GreenParatroopaJump   = $0e
000005r 3               RedParatroopa         = $0f
000005r 3               GreenParatroopaFly    = $10
000005r 3               Lakitu                = $11
000005r 3               Spiny                 = $12
000005r 3               FlyCheepCheepFrenzy   = $14
000005r 3               FlyingCheepCheep      = $14
000005r 3               BowserFlame           = $15
000005r 3               Fireworks             = $16
000005r 3               BBill_CCheep_Frenzy   = $17
000005r 3               Stop_Frenzy           = $18
000005r 3               Bowser                = $2d
000005r 3               PowerUpObject         = $2e
000005r 3               VineObject            = $2f
000005r 3               FlagpoleFlagObject    = $30
000005r 3               StarFlagObject        = $31
000005r 3               JumpspringObject      = $32
000005r 3               BulletBill_CannonVar  = $33
000005r 3               RetainerObject        = $35
000005r 3               TallEnemy             = $09
000005r 3               UpsideDownPiranhaP    = $04
000005r 3               
000005r 3               ;other constants
000005r 3               World1 = 0
000005r 3               World2 = 1
000005r 3               World3 = 2
000005r 3               World4 = 3
000005r 3               World5 = 4
000005r 3               World6 = 5
000005r 3               World7 = 6
000005r 3               World8 = 7
000005r 3               World9 = 8
000005r 3               WorldA = 9
000005r 3               WorldB = 10
000005r 3               WorldC = 11
000005r 3               WorldD = 12
000005r 3               Level1 = 0
000005r 3               Level2 = 1
000005r 3               Level3 = 2
000005r 3               Level4 = 3
000005r 3               
000005r 3               WarmBootOffset        = <$07d6
000005r 3               ColdBootOffset        = <$07fe
000005r 3               SoundMemory           = $07b0
000005r 3               
000005r 3               A_Button              = %10000000
000005r 3               B_Button              = %01000000
000005r 3               Select_Button         = %00100000
000005r 3               Start_Button          = %00010000
000005r 3               Up_Dir                = %00001000
000005r 3               Down_Dir              = %00000100
000005r 3               Left_Dir              = %00000010
000005r 3               Right_Dir             = %00000001
000005r 3               
000005r 3               AttractMode           = 0
000005r 3               GameMode              = 1
000005r 3               VictoryMode           = 2
000005r 3               GameOverMode          = 3
000005r 3               
000005r 3               PractiseBank          = $80
000005r 3               SoundBank             = $88
000005r 3               LevelsBank            = $8a
000005r 3               GameBank              = $8c
000005r 3               FixedBank             = $8e
000005r 3               
000005r 3               MMC3_BankSelect		  = $8000
000005r 3               MMC3_BankData		  = $8001
000005r 3               MMC3_Mirroring		  = $a000
000005r 3               MMC3_PRGRAMProtect    = $a001
000005r 3               
000005r 3               MMC3_IRQLatch		  = $c000
000005r 3               MMC3_IRQReload		  = $c001
000005r 3               MMC3_IRQDisable		  = $e000
000005r 3               MMC3_IRQEnable		  = $e001
000005r 3               
000005r 3               BG_GameBank           = $80
000005r 3               Spr_GameBank          = $84
000005r 3               BG_TitleBank          = $88
000005r 3               Spr_EndingBank        = $8c
000005r 3               
000005r 2               
000005r 2               ; import some pointers from the smb rom
000005r 2               .import GL_ENTER
000005r 2               .import GetAreaDataAddrs
000005r 2               .import LoadAreaPointer
000005r 2               .import EndWorld1Thru7
000005r 2               .import NMIHandler
000005r 2               .import IRQHandler
000005r 2               .import InitializeBG_CHR
000005r 2               .import InitializeSPR_CHR
000005r 2               
000005r 2               ; Temporary WRAM space
000005r 2               .segment "TEMPWRAM"
000000r 2  00 00 00 00  WRAMSaveHeader: .byte $00, $00, $00, $00, $00
000004r 2  00           
000005r 2  00           HeldButtons: .byte $00
000006r 2  00           ReleasedButtons: .byte $00
000007r 2  00           LastReadButtons: .byte $00
000008r 2  00           PressedButtons: .byte $00
000009r 2  00           CachedChangeAreaTimer: .byte $00
00000Ar 2  00           LevelEnding: .byte $00
00000Br 2  00           IsPlaying: .byte $00
00000Cr 2  00           EnteringFromMenu: .byte $00
00000Dr 2  00           PendingScoreDrawPosition: .byte $00
00000Er 2  00           CachedITC: .byte $00
00000Fr 2  00           PREVIOUS_BANK: .byte $00
000010r 2               
000010r 2               ; Persistent WRAM space
000010r 2               .segment "MENUWRAM"
000000r 2               MathDigits:
000000r 2               MathFrameruleDigitStart:
000000r 2  00 00 00 00    .byte $00, $00, $00, $00, $00 ; selected framerule
000004r 2  00           
000005r 2               MathFrameruleDigitEnd:
000005r 2               MathInGameFrameruleDigitStart:
000005r 2  00 00 00 00    .byte $00, $00, $00, $00, $00 ; ingame framerule
000009r 2  00           
00000Ar 2               MathInGameFrameruleDigitEnd:
00000Ar 2               
00000Ar 2               ; $7E00-$7FFF - relocated bank switching code
00000Ar 2               RelocatedCodeLocation = $7E00
00000Ar 2               
00000Ar 2               .segment "PRACTISE_PRG0"
000005r 2               ; ================================================================
000005r 2               ;  Full reset of title screen
000005r 2               ; ----------------------------------------------------------------
000005r 2               TitleResetInner:
000005r 2  A2 00            ldx #$00                           ; disable ppu
000007r 2  8E 00 20         stx PPU_CTRL_REG1                  ;
00000Ar 2  8E 01 20         stx PPU_CTRL_REG2                  ;
00000Dr 2  20 rr rr         jsr InitializeMemory               ; clear memory
000010r 2  20 rr rr         jsr ForceClearWRAM                 ; clear all wram state
000013r 2  A9 08            lda #8                             ; set starting framerule
000015r 2  8D rr rr         sta MathFrameruleDigitStart        ;
000018r 2  AD 02 20     :   lda PPU_STATUS                     ; wait for vblank
00001Br 2  10 FB            bpl :-                             ;
00001Dr 2               HotReset2:                             ;
00001Dr 2  A2 00            ldx #$00                           ; disable ppu again (this is called when resetting to the menu)
00001Fr 2  8E 00 20         stx PPU_CTRL_REG1                  ;
000022r 2  8E 01 20         stx PPU_CTRL_REG2                  ;
000025r 2  A2 FF            ldx #$FF                           ; clear stack
000027r 2  9A               txs                                ;
000028r 2  AD 02 20     :   lda PPU_STATUS                     ; wait for vblank
00002Br 2  10 FB            bpl :-                             ;
00002Dr 2  20 rr rr         jsr InitBankSwitchingCode          ; copy bankswitching code to wram
000030r 2  20 rr rr         jsr ReadJoypads                    ; read controller to prevent a held button at startup from registering
000033r 2  20 rr rr         jsr PrepareScreen                  ; load in palette and background
000036r 2  20 rr rr         jsr MenuReset                      ; reset main menu
000039r 2  A9 00            lda #0                             ; disable playing state
00003Br 2  8D rr rr         sta IsPlaying                      ;
00003Er 2  8D 05 20         sta PPU_SCROLL_REG                 ; clear scroll registers
000041r 2  8D 05 20         sta PPU_SCROLL_REG                 ;
000044r 2  A9 88            lda #%10001000                     ; enable ppu
000046r 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ;
000049r 2  8D 00 20         sta PPU_CTRL_REG1                  ;
00004Cr 2  4C rr rr     :   jmp :-                             ; infinite loop until NMI
00004Fr 2               ; ================================================================
00004Fr 2               
00004Fr 2               ; ================================================================
00004Fr 2               ;  Hot reset back to the title screen
00004Fr 2               ; ----------------------------------------------------------------
00004Fr 2               HotReset:
00004Fr 2  A9 00            lda #0                             ; kill any playing sounds
000051r 2  8D 15 40         sta SND_MASTERCTRL_REG             ;
000054r 2  20 rr rr         jsr InitializeMemory               ; clear memory
000057r 2  4C rr rr         jmp HotReset2                      ; then jump to the shared reset code
00005Ar 2               ; ================================================================
00005Ar 2               
00005Ar 2               ; ================================================================
00005Ar 2               ;  Handle NMI interrupts while in the title screen
00005Ar 2               ; ----------------------------------------------------------------
00005Ar 2               TitleNMI:
00005Ar 2  AD 78 07         lda Mirror_PPU_CTRL_REG1           ; disable nmi
00005Dr 2  29 7F            and #%01111111                     ;
00005Fr 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ; and update ppu state
000062r 2  8D 00 20         sta PPU_CTRL_REG1                  ;
000065r 2  2C 02 20         bit PPU_STATUS                     ; flip ppu status
000068r 2  20 rr rr         jsr WriteVRAMBufferToScreen        ; write any pending vram updates
00006Br 2  A9 00            lda #0                             ; clear scroll registers
00006Dr 2  8D 05 20         sta PPU_SCROLL_REG                 ;
000070r 2  8D 05 20         sta PPU_SCROLL_REG                 ;
000073r 2  A9 02            lda #$02                           ; copy sprites
000075r 2  8D 14 40         sta SPR_DMA                        ;
000078r 2  20 rr rr         jsr ReadJoypads                    ; read controller state
00007Br 2  20 rr rr         jsr MenuNMI                        ; and run menu code
00007Er 2  A9 1A            lda #%00011010                     ; set ppu mask state for menu
000080r 2  8D 01 20         sta PPU_CTRL_REG2                  ;
000083r 2  AD 78 07         lda Mirror_PPU_CTRL_REG1           ; get ppu mirror state
000086r 2  09 80            ora #%10000000                     ; and reactivate nmi
000088r 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ; update ppu state
00008Br 2  8D 00 20         sta PPU_CTRL_REG1                  ;
00008Er 2  40               rti                                ; and we are done for the frame
00008Fr 2               
00008Fr 2               ; ================================================================
00008Fr 2               ;  Sets up the all the fixed graphics for the title screen
00008Fr 2               ; ----------------------------------------------------------------
00008Fr 2               PrepareScreen:
00008Fr 2  A9 3F            lda #$3F                           ; move ppu to palette memory
000091r 2  8D 06 20         sta PPU_ADDRESS                    ;
000094r 2  A9 00            lda #$00                           ;
000096r 2  8D 06 20         sta PPU_ADDRESS                    ;
000099r 2  A2 00            ldx #0                             ;
00009Br 2  BD rr rr     :   lda MenuPalette,x                  ; and copy the menu palette
00009Er 2  8D 07 20         sta PPU_DATA                       ;
0000A1r 2  E8               inx                                ;
0000A2r 2  E0 20            cpx #(MenuPaletteEnd-MenuPalette)  ;
0000A4r 2  D0 F5            bne :-                             ;
0000A6r 2  A9 20            lda #$20                           ; move ppu to nametable 0
0000A8r 2  8D 06 20         sta PPU_ADDRESS                    ;
0000ABr 2  A2 00            ldx #0                             ;
0000ADr 2  8E 06 20         stx PPU_ADDRESS                    ;
0000B0r 2  BD rr rr     :   lda BGDATA+$000,x                  ; and copy every page of menu data
0000B3r 2  8D 07 20         sta PPU_DATA                       ;
0000B6r 2  E8               inx                                ;
0000B7r 2  D0 F7            bne :-                             ;
0000B9r 2  BD rr rr     :   lda BGDATA+$100,x                  ;
0000BCr 2  8D 07 20         sta PPU_DATA                       ;
0000BFr 2  E8               inx                                ;
0000C0r 2  D0 F7            bne :-                             ;
0000C2r 2  BD rr rr     :   lda BGDATA+$200,x                  ;
0000C5r 2  8D 07 20         sta PPU_DATA                       ;
0000C8r 2  E8               inx                                ;
0000C9r 2  D0 F7            bne :-                             ;
0000CBr 2  BD rr rr     :   lda BGDATA+$300,x                  ;
0000CEr 2  8D 07 20         sta PPU_DATA                       ;
0000D1r 2  E8               inx                                ;
0000D2r 2  D0 F7            bne :-                             ;
0000D4r 2  60               rts                                ;
0000D5r 2               ; ================================================================
0000D5r 2               
0000D5r 2               ; ================================================================
0000D5r 2               ;  Clear RAM and temporary WRAM
0000D5r 2               ; ----------------------------------------------------------------
0000D5r 2               InitializeMemory:
0000D5r 2  A9 00            lda #0                             ; clear A and X
0000D7r 2  A2 00            ldx #0                             ;
0000D9r 2  95 00        :   sta $0000,x                        ; clear relevant memory addresses
0000DBr 2  9D 00 02         sta $0200,x                        ;
0000DEr 2  9D 00 03         sta $0300,x                        ;
0000E1r 2  9D 00 04         sta $0400,x                        ;
0000E4r 2  9D 00 05         sta $0500,x                        ;
0000E7r 2  9D 00 06         sta $0600,x                        ;
0000EAr 2  9D 00 07         sta $0700,x                        ;
0000EDr 2  9D 00 60         sta $6000,x                        ;
0000F0r 2  E8               inx                                ; and loop for 256 bytes
0000F1r 2  D0 E6            bne :-                             ;
0000F3r 2  60               rts                                ;
0000F4r 2               ; ================================================================
0000F4r 2               
0000F4r 2               ; ================================================================
0000F4r 2               ;  Reinitialize WRAM if needed
0000F4r 2               ; ----------------------------------------------------------------
0000F4r 2               InitializeWRAM:
0000F4r 2  A2 05            ldx #ROMSaveHeaderLen              ; get length of the magic wram header
0000F6r 2  BD rr rr     :   lda ROMSaveHeader,x                ; check every byte of the header
0000F9r 2  DD rr rr         cmp WRAMSaveHeader,x               ; does it match?
0000FCr 2  D0 04            bne ForceClearWRAM                 ; no - clear wram
0000FEr 2  CA               dex                                ; yes - check next byte
0000FFr 2  10 F5            bpl :-                             ;
000101r 2  60               rts                                ;
000102r 2               ; ================================================================
000102r 2               
000102r 2               ; ================================================================
000102r 2               ;  Clear WRAM state
000102r 2               ; ----------------------------------------------------------------
000102r 2               ForceClearWRAM:
000102r 2                   @Ptr = $0
000102r 2  A9 60            lda #$60                           ; set starting address to $6000
000104r 2  85 01            sta @Ptr+1                         ;
000106r 2  A0 00            ldy #0                             ;
000108r 2  84 00            sty @Ptr+0                         ;
00010Ar 2  A2 80            ldx #$80                           ; and mark ending address at $8000
00010Cr 2  A9 00            lda #$00                           ; clear A
00010Er 2  91 00        :   sta (@Ptr),y                       ; clear one byte of WRAM
000110r 2  C8               iny                                ; and advance
000111r 2  D0 FB            bne :-                             ; for 256 bytes
000113r 2  E6 01            inc @Ptr+1                         ; then advance to the next page
000115r 2  E4 01            cpx @Ptr+1                         ; check if we are at the ending page
000117r 2  D0 F5            bne :-                             ; no - keep clearing data
000119r 2  A2 05            ldx #ROMSaveHeaderLen              ; otherwise copy the magic wram header
00011Br 2  BD rr rr     :   lda ROMSaveHeader,x                ;
00011Er 2  9D rr rr         sta WRAMSaveHeader,x               ;
000121r 2  CA               dex                                ;
000122r 2  10 F7            bpl :-                             ;
000124r 2  60               rts                                ;
000125r 2               ; ================================================================
000125r 2               
000125r 2               ; include all of the relevant title files
000125r 2               .include "practise.asm"
000125r 3               ; ===========================================================================
000125r 3               ;  Start the game!
000125r 3               ; ---------------------------------------------------------------------------
000125r 3               TStartGame:
000125r 3                   @FRDigits = (MathFrameruleDigitEnd-MathFrameruleDigitStart-1)
000125r 3  20 rr rr         jsr InitBankSwitchingCode                    ; copy utility code to WRAM
000128r 3  A2 04            ldx #@FRDigits                               ; set up framerule digits
00012Ar 3               @KeepCopying:                                    ;
00012Ar 3  BD rr rr         lda MathFrameruleDigitStart, x               ; copy each framerule digit from the menu
00012Dr 3  9D rr rr         sta MathInGameFrameruleDigitStart, x         ;
000130r 3  CA               dex                                          ;
000131r 3  10 F7            bpl @KeepCopying                             ;
000133r 3  18               clc                                          ;
000134r 3  A9 01            lda #1                                       ; set flag indicating we are entering from the menu
000136r 3  8D rr rr         sta EnteringFromMenu                         ;
000139r 3  8D 70 07         sta OperMode                                 ; set starting opermode to "gamemode"
00013Cr 3  8D rr rr         sta IsPlaying                                ; mark that we are in game mode
00013Fr 3  4A               lsr a                                        ; clear A
000140r 3  8D 72 07         sta OperMode_Task                            ; clear opermode task value
000143r 3  85 0E            sta GameEngineSubroutine                     ; clear game engine task
000145r 3  8D 47 07         sta TimerControl                             ; mark the game as running
000148r 3  8D rr rr         sta PendingScoreDrawPosition                 ; clear pending status bar draw flag
00014Br 3  8D 00 20         sta PPU_CTRL_REG1                            ; diable rendering
00014Er 3  8D 78 07         sta Mirror_PPU_CTRL_REG1                     ;
000151r 3  8D 01 20         sta PPU_CTRL_REG2                            ;
000154r 3  8D 15 40         sta $4015                                    ; silence music
000157r 3  85 FC            sta EventMusicQueue                          ; stop music queue
000159r 3  AE rr rr         ldx SettablesWorld                           ; copy menu world number
00015Cr 3  8E 5F 07         stx WorldNumber                              ;
00015Fr 3  AE rr rr         ldx SettablesLevel                           ; copy menu level number
000162r 3  8E 5C 07         stx LevelNumber                              ;
000165r 3  AE rr rr         ldx SettablesPUP                             ; get menu powerup state
000168r 3  BD rr rr         lda @StatusSizes,x                           ; get player size based on menu state
00016Br 3  8D 54 07         sta PlayerSize                               ; and update player size
00016Er 3  BD rr rr         lda @StatusPowers,x                          ; get player power state based on menu state
000171r 3  8D 56 07         sta PlayerStatus                             ; and update player status
000174r 3  AD rr rr         lda SettablesHero                            ; set current player
000177r 3  8D 53 07         sta SelectedPlayer                           ;
00017Ar 3  AD rr rr         lda SettablesW9                              ; if world 9 not enabled, branch ahead
00017Dr 3  F0 05            beq @EndCopy                                 ;
00017Fr 3  A9 FF            lda #$ff                                     ; otherwise mark all worlds as completed
000181r 3  8D FA 07         sta CompletedWorlds                          ;
000184r 3               @EndCopy:                                        ;
000184r 3  A9 02            lda #$2                                      ; give player 3 lives
000186r 3  8D 5A 07         sta NumberofLives                            ;
000189r 3  A9 04            lda #$4                                      ; set the interval timer to a hardcoded value
00018Br 3  8D 7F 07         sta IntervalTimerControl                     ;
00018Er 3  EE 57 07         inc FetchNewGameTimerFlag                    ; tell the game to reload the game timer
000191r 3  A9 08            lda #$08                                     ; set number of games beaten
000193r 3  8D 07 60         sta GamesBeatenCount                         ; to always enable letter worlds
000196r 3  4C rr rr         jmp BANK_AdvanceToLevel                      ; transition to the wram code to start the game
000199r 3               @StatusSizes:
000199r 3  01 00 00 00  .byte $1, $0, $0, $0, $1, $1
00019Dr 3  01 01        
00019Fr 3               @StatusPowers:
00019Fr 3  00 01 02 00  .byte $0, $1, $2, $0, $1, $2
0001A3r 3  01 02        
0001A5r 3               ; ===========================================================================
0001A5r 3               
0001A5r 3               ; ===========================================================================
0001A5r 3               ;  Practise routine per frame routine
0001A5r 3               ; ---------------------------------------------------------------------------
0001A5r 3               PractiseNMI:
0001A5r 3  AD rr rr         lda EnteringFromMenu                         ; are we currently entering from the menu?
0001A8r 3  F0 01            beq @ClearPractisePrintScore                 ; no - then we can run our routine
0001AAr 3  60               rts                                          ; otherwise, we're loading, so just return
0001ABr 3               @ClearPractisePrintScore:                        ;
0001ABr 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; check if we have pending ppu draws
0001AEr 3  D0 03            bne @IncrementFrameruleCounter               ; yes - skip ahead
0001B0r 3  8D rr rr         sta PendingScoreDrawPosition                 ; no - clear pending vram address for framerule drawing
0001B3r 3               @IncrementFrameruleCounter:                      ;
0001B3r 3  20 rr rr         jsr IncrementFrameruleCounter                ; increment the base10 framerule counter
0001B6r 3  20 rr rr         jsr CheckForLevelEnd                         ; run level transition handler
0001B9r 3  20 rr rr         jsr CheckJumpingState                        ; run jump handler
0001BCr 3  20 rr rr         jsr CheckAreaTimer                           ; run area transition timing handler
0001BFr 3  20 rr rr         jsr CheckForWorldEnd                         ; run end of world handler
0001C2r 3               @CheckUpdateStatusbarValues:                     ;
0001C2r 3  A5 09            lda FrameCounter                             ; get current frame counter
0001C4r 3  29 03            and #3                                       ; and just make sure we're in a specific 4 frame spot
0001C6r 3  C9 02            cmp #2                                       ;
0001C8r 3  D0 03            bne @CheckInput                              ; if not, skip ahead
0001CAr 3  20 rr rr         jsr RedrawHighFreqStatusbar                  ; otherwise update status bar
0001CDr 3               @CheckInput:                                     ;
0001CDr 3  AD 4A 07         lda JoypadBitMask                            ; get current joypad state
0001D0r 3  29 30            and #(Select_Button | Start_Button)          ; mask out all but select and start
0001D2r 3  F0 24            beq @Done                                    ; neither are held - nothing more to do here
0001D4r 3  20 rr rr         jsr ReadJoypads                              ; re-read joypad state, to avoid filtering from the game
0001D7r 3               @CheckForRestartLevel:                           ;
0001D7r 3  C9 28            cmp #(Up_Dir | Select_Button)                ; check if select + up are held
0001D9r 3  D0 0E            bne @CheckForReset                           ; no - skip ahead
0001DBr 3  A9 00            lda #0                                       ; yes - we are restarting the level
0001DDr 3  8D 00 20         sta PPU_CTRL_REG1                            ; disable screen rendering
0001E0r 3  8D 01 20         sta PPU_CTRL_REG2                            ;
0001E3r 3  20 rr rr         jsr InitializeMemory                         ; clear memory
0001E6r 3  4C rr rr         jmp TStartGame                               ; and start the game
0001E9r 3               @CheckForReset:                                  ;
0001E9r 3  C9 24            cmp #(Down_Dir | Select_Button)              ; check if select + down are held
0001EBr 3  D0 0B            bne @Done                                    ; no - skip ahead
0001EDr 3  A9 00            lda #0                                       ; yes - we are returning to the title screen
0001EFr 3  8D 00 20         sta PPU_CTRL_REG1                            ; disable screen rendering
0001F2r 3  8D 01 20         sta PPU_CTRL_REG2                            ;
0001F5r 3  4C rr rr         jmp HotReset                                 ; and reset the game
0001F8r 3               @Done:                                           ;
0001F8r 3  60               rts                                          ;
0001F9r 3               ; ===========================================================================
0001F9r 3               
0001F9r 3               ; ===========================================================================
0001F9r 3               ;  Handle new area loading loading
0001F9r 3               ; ---------------------------------------------------------------------------
0001F9r 3               PractiseEnterStage:
0001F9r 3                   @FRDigitCount = MathFrameruleDigitEnd - MathFrameruleDigitStart - 1
0001F9r 3  A9 03            lda #3                                       ; set life counter to four by default
0001FBr 3  8D 5A 07         sta NumberofLives                            ; so we can't lose the game
0001FEr 3  AD rr rr         lda EnteringFromMenu                         ; check if we're entering from the menu
000201r 3  F0 0F            beq @SaveToMenu                              ; no, the player beat a level, update the menu state
000203r 3  38               sec                                          ; yes, the player is starting a new game
000204r 3  A5 09            lda FrameCounter                             ; we need to offset the frame counter a little bit
000206r 3  E9 06            sbc #6                                       ;
000208r 3  85 09            sta FrameCounter                             ;
00020Ar 3  20 rr rr         jsr RNGQuickResume                           ; and load the rng state
00020Dr 3  CE rr rr         dec EnteringFromMenu                         ; then mark that we've entered from the menu, so this doesn't happen again
000210r 3  F0 46            beq @Shared                                  ; and skip ahead to avoid saving the state for no reason
000212r 3               @SaveToMenu:                                     ;
000212r 3  AD rr rr         lda LevelEnding                              ; check if we are transitioning to a new level
000215r 3  F0 41            beq @Shared                                  ; no - skip ahead and enter the game
000217r 3  A2 04            ldx #@FRDigitCount                           ; yes - copy the framerule to the menu
000219r 3  BD rr rr     :   lda MathInGameFrameruleDigitStart,x          ;
00021Cr 3  9D rr rr         sta MathFrameruleDigitStart,x                ;
00021Fr 3  CA               dex                                          ;
000220r 3  10 F7            bpl :-                                       ;
000222r 3  AD 5F 07         lda WorldNumber                              ; copy current world and level to the menu
000225r 3  AE FB 07         ldx HardWorldFlag                            ; check if we're in the letter worlds
000228r 3  F0 03            beq @SaveWorldNum                            ; if not, branch to save world number
00022Ar 3  18               clc                                          ; otherwise add 9 to internal world number
00022Br 3  69 09            adc #$09                                     ; for world selection in menu and level restart
00022Dr 3               @SaveWorldNum:                                   ;
00022Dr 3  8D rr rr         sta SettablesWorld                           ;
000230r 3  AD 5C 07         lda LevelNumber                              ;
000233r 3  8D rr rr         sta SettablesLevel                           ;
000236r 3  AD 54 07         lda PlayerSize                               ; get player powerup state
000239r 3  0A               asl a                                        ; shift up a couple of bits to make room for powerup state
00023Ar 3  0A               asl a                                        ;
00023Br 3  0D 56 07         ora PlayerStatus                             ; combine with powerup state
00023Er 3  AA               tax                                          ; copy to X
00023Fr 3  BD rr rr         lda @PUpStates,x                             ; and get the menu selection values from the players current state
000242r 3  8D rr rr         sta SettablesPUP                             ; and write to menu powerup state
000245r 3  AD 53 07         lda SelectedPlayer                           ; save currently selected player
000248r 3  8D rr rr         sta SettablesHero                            ;
00024Br 3  A2 00            ldx #$00                                     ; clear world 9 enable flag by default
00024Dr 3  AD FA 07         lda CompletedWorlds                          ; check completed worlds variable
000250r 3  C9 FF            cmp #$ff                                     ; if not all worlds marked as completed,
000252r 3  D0 01            bne @StoreW9Flag                             ; world 9 will not be marked as enabled
000254r 3  E8               inx                                          ; otherwise increment X for world 9 enable
000255r 3               @StoreW9Flag:                                    ;
000255r 3  8E rr rr         stx SettablesW9                              ;
000258r 3               @Shared:                                         ;
000258r 3  A9 00            lda #0                                       ; clear out some starting state
00025Ar 3  8D rr rr         sta CachedChangeAreaTimer                    ;
00025Dr 3  8D rr rr         sta LevelEnding                              ;
000260r 3  4C rr rr         jmp RedrawLowFreqStatusbar                   ; and update the status line
000263r 3               @PUpStates:
000263r 3  03           .byte $3                                         ; size = 0, status = 0. big vuln. mario
000264r 3  01           .byte $1                                         ; size = 0, status = 1. big super mario
000265r 3  02           .byte $2                                         ; size = 0, status = 2. big fire mario
000266r 3  02           .byte $2                                         ; size = 0, status = 3. big fire mario, padding
000267r 3  00           .byte $0                                         ; size = 1, status = 0. small vuln. mario
000268r 3  05           .byte $5                                         ; size = 1, status = 1. small super mario
000269r 3  06           .byte $6                                         ; size = 1, status = 2. small fire mario
00026Ar 3               ; ===========================================================================
00026Ar 3               
00026Ar 3               ; ===========================================================================
00026Ar 3               ;  Handle level transitions
00026Ar 3               ; ---------------------------------------------------------------------------
00026Ar 3               CheckForLevelEnd:
00026Ar 3  AD rr rr         lda LevelEnding                              ; have we already detected the level end?
00026Dr 3  D0 1E            bne @Done                                    ; if so - exit
00026Fr 3  AD 3C 07         lda ScreenRoutineTask
000272r 3  C9 07            cmp #7
000274r 3  F0 14            beq @LevelEnding
000276r 3  AD 46 07         lda StarFlagTaskControl                      ; check the current starflag state
000279r 3  C9 04            cmp #4                                       ; are we in the final starflag task?
00027Br 3  D0 10            bne @Done                                    ; no - exit
00027Dr 3  AD 7F 07         lda IntervalTimerControl                     ; cache the current interval timer
000280r 3  8D rr rr         sta CachedITC                                ;
000283r 3  18               clc                                          ;
000284r 3  20 rr rr         jsr ChangeTopStatusXToRemains                ; change the 'X' in the title to 'R'
000287r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; and redraw the status bar
00028Ar 3               @LevelEnding:
00028Ar 3  EE rr rr         inc LevelEnding                              ; yes - mark the level end as ended
00028Dr 3               @Done:                                           ;
00028Dr 3  60               rts                                          ;
00028Er 3               ; ===========================================================================
00028Er 3               
00028Er 3               ; ===========================================================================
00028Er 3               ;  Handle area transitions (pipes, etc)
00028Er 3               ; ---------------------------------------------------------------------------
00028Er 3               CheckAreaTimer:
00028Er 3  AD rr rr         lda CachedChangeAreaTimer                    ; have we already handled the area change?
000291r 3  D0 15            bne @Done                                    ; yes - exit
000293r 3  AD DE 06         lda ChangeAreaTimer                          ; no - check if we should handle it
000296r 3  F0 10            beq @Done                                    ; no - exit
000298r 3  8D rr rr         sta CachedChangeAreaTimer                    ; yes - cache the timer value
00029Br 3  AD 7F 07         lda IntervalTimerControl                     ; get the interval timer
00029Er 3               @Store2:                                         ;
00029Er 3  8D rr rr         sta CachedITC                                ; and cache it as well
0002A1r 3  18               clc                                          ;
0002A2r 3  20 rr rr         jsr ChangeTopStatusXToRemains                ; change the 'X' in the title to 'R'
0002A5r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; and redraw the status bar
0002A8r 3               @Done:                                           ;
0002A8r 3  60               rts                                          ;
0002A9r 3               ; ===========================================================================
0002A9r 3               
0002A9r 3               ; ===========================================================================
0002A9r 3               ;  Handle end of castle transitions
0002A9r 3               ; ---------------------------------------------------------------------------
0002A9r 3               CheckForWorldEnd:
0002A9r 3  AD rr rr         lda LevelEnding                              ; have we already detected the level end?
0002ACr 3  F0 09            beq @CheckWorldEndTimer                      ; if not - check for world end timer
0002AEr 3  4A               lsr                                          ; shift A right to discard d0
0002AFr 3  D0 1D            bne @Done                                    ; if d1 is set - exit
0002B1r 3  AD 80 07         lda SelectTimer                              ; otherwise check for select timer
0002B4r 3  D0 08            bne @DisplayIntervalTimer                    ; if set, display mod 21 remainder
0002B6r 3  60               rts                                          ; otherwise leave
0002B7r 3               @CheckWorldEndTimer:                             ;
0002B7r 3  AD A1 07         lda WorldEndTimer                            ; check world end timer
0002BAr 3  C9 08            cmp #8                                       ; has it been set to 8 or greater?
0002BCr 3  90 10            bcc @Done                                    ; if not, leave
0002BEr 3               @DisplayIntervalTimer:                           ;
0002BEr 3  AD 7F 07         lda IntervalTimerControl                     ; cache the current interval timer
0002C1r 3  8D rr rr         sta CachedITC                                ;
0002C4r 3  18               clc                                          ;
0002C5r 3  20 rr rr         jsr ChangeTopStatusXToRemains                ; change the 'X' in the title to 'R'
0002C8r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; and redraw the status bar
0002CBr 3  EE rr rr         inc LevelEnding                              ; yes - mark the level end as ended
0002CEr 3               @Done:
0002CEr 3  60               rts
0002CFr 3               
0002CFr 3               ; ===========================================================================
0002CFr 3               
0002CFr 3               ; ===========================================================================
0002CFr 3               ;  Handle player jumping
0002CFr 3               ; ---------------------------------------------------------------------------
0002CFr 3               CheckJumpingState:
0002CFr 3  AD 82 07         lda JumpSwimTimer                            ; check jump timer
0002D2r 3  C9 20            cmp #$20                                     ; is it the max value (player just jumped)
0002D4r 3  D0 03            bne @Done                                    ; no - exit
0002D6r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; yes - redraw the status bar
0002D9r 3               @Done:                                           ;
0002D9r 3  60               rts                                          ; done!
0002DAr 3               ; ===========================================================================
0002DAr 3               
0002DAr 3               ; ===========================================================================
0002DAr 3               ;  Advance to the next base 10 framerule digit
0002DAr 3               ; ---------------------------------------------------------------------------
0002DAr 3               IncrementFrameruleCounter:
0002DAr 3                   @DigitOffset = (MathInGameFrameruleDigitStart-MathDigits)
0002DAr 3  AD 47 07         lda TimerControl                             ; check if the game is running
0002DDr 3  D0 0F            bne @Done                                    ; no - exit
0002DFr 3  AC 7F 07         ldy IntervalTimerControl                     ; get the interval timer
0002E2r 3  C0 01            cpy #1                                       ; are we at the end of the interval?
0002E4r 3  D0 08            bne @Done                                    ; no - exit
0002E6r 3  18               clc                                          ;
0002E7r 3  A9 01            lda #1                                       ; we want to add 1 to the digits
0002E9r 3  A2 05            ldx #@DigitOffset                            ; get the offset to the digit we are incrementing
0002EBr 3  4C rr rr         jmp B10Add                                   ; and run base 10 addition
0002EEr 3               @Done:                                           ;
0002EEr 3  60               rts                                          ;
0002EFr 3               ; ===========================================================================
0002EFr 3               
0002EFr 3               ; ===========================================================================
0002EFr 3               ;  Handle when the game wants to redraw the MARIO / TIME text at the top
0002EFr 3               ; ---------------------------------------------------------------------------
0002EFr 3               PractiseWriteTopStatusLine:
0002EFr 3  18               clc                                          ;
0002F0r 3  AC 00 03         ldy VRAM_Buffer1_Offset                      ; get current vram offset
0002F3r 3  A9 2D            lda #(@TopStatusTextEnd-@TopStatusText+1)    ; get text length
0002F5r 3  6D 00 03         adc VRAM_Buffer1_Offset                      ; add to vram offset
0002F8r 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; and store new offset
0002FBr 3  A2 00            ldx #0                                       ;
0002FDr 3               @CopyData:                                       ;
0002FDr 3  BD rr rr         lda @TopStatusText,x                         ; copy bytes of the status bar text to vram
000300r 3  99 01 03         sta VRAM_Buffer1,y                           ;
000303r 3  C8               iny                                          ; advance vram offset
000304r 3  E8               inx                                          ; advance text offset
000305r 3  E0 2C            cpx #(@TopStatusTextEnd-@TopStatusText)      ; check if we're at the end
000307r 3  D0 F4            bne @CopyData                                ; if not, loop
000309r 3  A9 00            lda #0                                       ; then set null terminator at the end
00030Br 3  99 01 03         sta VRAM_Buffer1,y                           ;
00030Er 3  EE 3C 07         inc ScreenRoutineTask                        ; and advance the screen routine task
000311r 3  60               rts                                          ; done
000312r 3               @TopStatusText:                                  ;
000312r 3  20 43 15 1B    .byte $20, $43,  21, "RULE x SOCKS TO FRAME"   ;
000316r 3  1E 15 0E 24  
00031Ar 3  29 24 1C 18  
00032Ar 3  20 59 04 1D    .byte $20, $59,   4, "TIME"                    ;
00032Er 3  12 16 0E     
000331r 3  20 73 02 2E    .byte $20, $73,   2, $2e, $29                  ; coin that shows next to the coin counter
000335r 3  29           
000336r 3  23 C0 7F AA    .byte $23, $c0, $7f, $aa                       ; tile attributes for the top row, sets palette
00033Ar 3  23 C4 01 E0    .byte $23, $c4, $01, %11100000                 ; set palette for the flashing coin
00033Er 3               @TopStatusTextEnd:
00033Er 3  00              .byte $00
00033Fr 3               ; ===========================================================================
00033Fr 3               
00033Fr 3               ; ===========================================================================
00033Fr 3               ;  Handle the game requesting redrawing the bottom status bar
00033Fr 3               ; ---------------------------------------------------------------------------
00033Fr 3               PractiseWriteBottomStatusLine:
00033Fr 3  AD 7F 07         lda IntervalTimerControl                     ; no, get the current interval timer
000342r 3  8D rr rr         sta CachedITC                                ; and store it in the cached value
000345r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; redraw the status bar
000348r 3  EE 3C 07         inc ScreenRoutineTask                        ; and advance to the next smb screen routine
00034Br 3  60               rts                                          ;
00034Cr 3               ; ===========================================================================
00034Cr 3               
00034Cr 3               ; ===========================================================================
00034Cr 3               ;  Place an "R" instead of "x" in the title screen during level transitions
00034Cr 3               ; ---------------------------------------------------------------------------
00034Cr 3               ChangeTopStatusXToRemains:
00034Cr 3  18               clc                                          ;
00034Dr 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get current vram offset
000350r 3  A8               tay                                          ;
000351r 3  69 04            adc #4                                       ; and advance it by 4
000353r 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; store the new offset
000356r 3  A9 20            lda #$20                                     ; write the ppu address to update
000358r 3  99 01 03         sta VRAM_Buffer1+0, y                        ;
00035Br 3  A9 48            lda #$48                                     ;
00035Dr 3  99 02 03         sta VRAM_Buffer1+1, y                        ;
000360r 3  A9 01            lda #1                                       ; we are writing a single byte
000362r 3  99 03 03         sta VRAM_Buffer1+2, y                        ;
000365r 3  A9 1B            lda #'R'                                     ; and that byte is an R
000367r 3  99 04 03         sta VRAM_Buffer1+3, y                        ;
00036Ar 3  A9 00            lda #0                                       ; set the null terminator
00036Cr 3  99 05 03         sta VRAM_Buffer1+4, y                        ;
00036Fr 3  60               rts                                          ; and finish
000370r 3               ; ===========================================================================
000370r 3               
000370r 3               ; ===========================================================================
000370r 3               ;  Redraw the status bar portion that updates less often
000370r 3               ; ---------------------------------------------------------------------------
000370r 3               RedrawLowFreqStatusbar:
000370r 3  18               clc                                          ;
000371r 3  AC rr rr         ldy PendingScoreDrawPosition                 ; check if we have a pending draw that hasn't been sent to the ppu
000374r 3  D0 12            bne @RefreshBufferX                          ; yes - skip ahead and refresh the buffer to avoid overloading the ppu
000376r 3  AC 00 03         ldy VRAM_Buffer1_Offset                      ; no - get the current buffer offset
000379r 3  C8               iny                                          ; increment past the ppu location
00037Ar 3  C8               iny                                          ;
00037Br 3  C8               iny                                          ;
00037Cr 3  8C rr rr         sty PendingScoreDrawPosition                 ; and store it as our pending position
00037Fr 3  20 rr rr         jsr @PrintRule                               ; draw the current framerule value
000382r 3  20 rr rr         jsr @PrintFramecounter                       ; draw the current framecounter value
000385r 3  A6 08            ldx ObjectOffset                             ; load object offset, our caller might expect it to be unchanged
000387r 3  60               rts                                          ; and exit
000388r 3               @RefreshBufferX:                                 ;
000388r 3  20 rr rr         jsr @PrintRuleDataAtY                        ; refresh pending framerule value
00038Br 3  98               tya                                          ; get the buffer offset we're drawing to
00038Cr 3  69 09            adc #9                                       ; and shift over to the framecounter position
00038Er 3  A8               tay                                          ;
00038Fr 3  20 rr rr         jsr @PrintFramecounterDataAtY                ; and then refresh the pending frame ounter value
000392r 3  A6 08            ldx ObjectOffset                             ; load object offset, our caller might expect it to be unchanged
000394r 3  60               rts                                          ; and exit
000395r 3               ; ---------------------------------------------------------------------------
000395r 3               ;  Copy current framerule number to VRAM
000395r 3               ; ---------------------------------------------------------------------------
000395r 3               @PrintRule:
000395r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get the current buffer offset
000398r 3  A8               tay                                          ;
000399r 3  69 09            adc #(3+6)                                   ; shift over based on length of the framerule text
00039Br 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; store the ppu location of the framerule counter
00039Er 3  A9 20            lda #$20                                     ;
0003A0r 3  99 01 03         sta VRAM_Buffer1,y                           ;
0003A3r 3  A9 63            lda #$63                                     ;
0003A5r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
0003A8r 3  A9 06            lda #$06                                     ; store the number of digits to draw
0003AAr 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
0003ADr 3  C8               iny                                          ; increment past the ppu location
0003AEr 3  C8               iny                                          ;
0003AFr 3  C8               iny                                          ;
0003B0r 3  A9 00            lda #0                                       ; place our null terminator
0003B2r 3  99 07 03         sta VRAM_Buffer1+6,y                         ;
0003B5r 3  A9 24            lda #$24                                     ; and write a space past the framerule (masks out smb1 '0' after the score)
0003B7r 3  99 05 03         sta VRAM_Buffer1+4,y                         ;
0003BAr 3               @PrintRuleDataAtY:
0003BAr 3  AD rr rr         lda CachedITC                                ; get the interval timer for when we entered the room
0003BDr 3  99 06 03         sta VRAM_Buffer1+5,y                         ; and store it in the buffer
0003C0r 3  AD rr rr         lda MathInGameFrameruleDigitStart+3          ; then copy the framerule numbers into the buffer
0003C3r 3  99 01 03         sta VRAM_Buffer1+0,y                         ;
0003C6r 3  AD rr rr         lda MathInGameFrameruleDigitStart+2          ;
0003C9r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
0003CCr 3  AD rr rr         lda MathInGameFrameruleDigitStart+1          ;
0003CFr 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
0003D2r 3  AD rr rr         lda MathInGameFrameruleDigitStart+0          ;
0003D5r 3  99 04 03         sta VRAM_Buffer1+3,y                         ;
0003D8r 3  60               rts                                          ;
0003D9r 3               ; ---------------------------------------------------------------------------
0003D9r 3               ;  Copy current frame number to VRAM
0003D9r 3               ; ---------------------------------------------------------------------------
0003D9r 3               @PrintFramecounter:
0003D9r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get current vram offset
0003DCr 3  A8               tay                                          ;
0003DDr 3  69 06            adc #(3+3)                                   ; add 3 for vram offset, 3 for values to draw
0003DFr 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; save new vram offset
0003E2r 3  A9 20            lda #$20                                     ; store the ppu location of the frame number
0003E4r 3  99 01 03         sta VRAM_Buffer1,y                           ;
0003E7r 3  A9 75            lda #$75                                     ;
0003E9r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
0003ECr 3  A9 03            lda #$03                                     ; store the number of digits to draw
0003EEr 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
0003F1r 3  C8               iny                                          ; advance y to the end of the buffer to write
0003F2r 3  C8               iny                                          ;
0003F3r 3  C8               iny                                          ;
0003F4r 3  A9 00            lda #0                                       ; place our null terminator
0003F6r 3  99 04 03         sta VRAM_Buffer1+3,y                         ;
0003F9r 3               @PrintFramecounterDataAtY:                       ;
0003F9r 3  A5 09            lda FrameCounter                             ; get the current frame number
0003FBr 3  20 rr rr         jsr B10DivBy10                               ; divide by 10
0003FEr 3  99 03 03         sta VRAM_Buffer1+2,y                         ; store remainder in vram buffer
000401r 3  8A               txa                                          ; get the result of the divide
000402r 3  20 rr rr         jsr B10DivBy10                               ; divide by 10
000405r 3  99 02 03         sta VRAM_Buffer1+1,y                         ; store remainder in vram buffer
000408r 3  8A               txa                                          ; get the result of the divide
000409r 3  99 01 03         sta VRAM_Buffer1+0,y                         ; and store it in vram
00040Cr 3  60               rts                                          ;
00040Dr 3               ; ===========================================================================
00040Dr 3               
00040Dr 3               ; ===========================================================================
00040Dr 3               ;  Update and draw status bar values
00040Dr 3               ; ---------------------------------------------------------------------------
00040Dr 3               RedrawHighFreqStatusbar:
00040Dr 3                   @SockSubX = $2                               ; memory locations that sockfolder is stored in
00040Dr 3                   @SockX    = $3                               ;
00040Dr 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; check if there are pending ppu updates
000410r 3  F0 01            beq :+                                       ; no - skip ahead to update status bar
000412r 3  60               rts                                          ; yes - don't overload the ppu
000413r 3  20 rr rr     :   jsr RecalculateSockfolder                    ; calculate new sockfolder value
000416r 3               
000416r 3  A2 00            ldx #0                                       ; clear X
000418r 3  A9 20            lda #$20                                     ; write ppu location of status bar to vram buffer
00041Ar 3  9D 01 03         sta VRAM_Buffer1+0,x                         ;
00041Dr 3  A9 6A            lda #$6A                                     ;
00041Fr 3  9D 02 03         sta VRAM_Buffer1+1,x                         ;
000422r 3  A9 08            lda #8                                       ; write number of bytes to draw
000424r 3  9D 03 03         sta VRAM_Buffer1+2,x                         ;
000427r 3  A9 0B            lda #(8+3)                                   ; and update vram buffer offset to new location
000429r 3  8D 00 03         sta VRAM_Buffer1_Offset                      ;
00042Cr 3  A9 24            lda #$24                                     ; write spaces to a couple of locations
00042Er 3  9D 06 03         sta VRAM_Buffer1+3+2,x                       ;
000431r 3  9D 09 03         sta VRAM_Buffer1+3+5,x                       ;
000434r 3  A9 00            lda #0                                       ; write null terminator
000436r 3  9D 0C 03         sta VRAM_Buffer1+3+8,x                       ;
000439r 3               
000439r 3  A5 03            lda @SockX                                   ; get sockfolder x position
00043Br 3  29 0F            and #$0F                                     ; mask off the high nibble
00043Dr 3  9D 04 03         sta VRAM_Buffer1+3+0,x                       ; and write that byte to the vram buffer
000440r 3  A5 02            lda @SockSubX                                ; get sockfolder subpixel x position
000442r 3  4A               lsr                                          ; and shift down to the low nibble
000443r 3  4A               lsr                                          ;
000444r 3  4A               lsr                                          ;
000445r 3  4A               lsr                                          ;
000446r 3  9D 05 03         sta VRAM_Buffer1+3+1,x                       ; and write that byte to the vram buffer
000449r 3  AD 05 07         lda Player_X_MoveForce                       ; get the current player subpixel
00044Cr 3  A8               tay                                          ; copy to Y
00044Dr 3  29 0F            and #$0F                                     ; mask off the high nibble
00044Fr 3  9D 08 03         sta VRAM_Buffer1+3+4,x ; Y                   ; and write that byte to the vram buffer
000452r 3  98               tya                                          ; restore full value from Y
000453r 3  4A               lsr                                          ; and shift down to the low nibble
000454r 3  4A               lsr                                          ;
000455r 3  4A               lsr                                          ;
000456r 3  4A               lsr                                          ;
000457r 3  9D 07 03         sta VRAM_Buffer1+3+3,x ; Y                   ; and write that byte to the vram buffer
00045Ar 3  AD 50 07         lda AreaPointer                              ; get the pointer to where warp pipes direct player
00045Dr 3  A8               tay                                          ; copy to Y
00045Er 3  29 0F            and #$0F                                     ; mask off the high nibble
000460r 3  9D 0B 03         sta VRAM_Buffer1+3+7,x ; X                   ; and write that byte to the vram buffer
000463r 3  98               tya                                          ; restore full value from Y
000464r 3  4A               lsr                                          ; and shift down to the low nibble
000465r 3  4A               lsr                                          ;
000466r 3  4A               lsr                                          ;
000467r 3  4A               lsr                                          ;
000468r 3  9D 0A 03         sta VRAM_Buffer1+3+6,x ; X                   ; and write that byte to the vram buffer
00046Br 3               @skip:                                           ;
00046Br 3  60               rts                                          ;
00046Cr 3               ; ===========================================================================
00046Cr 3               
00046Cr 3               
00046Cr 3               ; ===========================================================================
00046Cr 3               ;  Calculate the current sockfolder value
00046Cr 3               ; ---------------------------------------------------------------------------
00046Cr 3               ; Sockfolder is effectively calculated by the following formula:
00046Cr 3               ;  Player_X_Position + ((0xFF - Player_Y_Position) / MaximumYSpeed) * MaximumXSpeed
00046Cr 3               ;
00046Cr 3               ; So that will give you the position that mario would be when he reaches the
00046Cr 3               ; bottom of the screen assuming the player is falling at full speed.
00046Cr 3               ;
00046Cr 3               ; Here's a little javascript snippet that creates a 16 bit lookup table of sockfolder values:
00046Cr 3               ;
00046Cr 3               ;; // NTSC:
00046Cr 3               ;; let max_x_speed = 0x0280; // maximum x speed in subpixels
00046Cr 3               ;; let max_y_speed = 0x04;   // maximum y speed in pixels
00046Cr 3               ;; // PAL:
00046Cr 3               ;; //let max_x_speed = 0x0300; // maximum x speed in subpixels
00046Cr 3               ;; //let max_y_speed = 0x05;   // maximum y speed in pixels
00046Cr 3               ;;
00046Cr 3               ;; let values = [];
00046Cr 3               ;; for (let i=0xFF; i>=0x00; --i) {
00046Cr 3               ;;     let value = Math.floor(i/max_y_speed)*max_x_speed;
00046Cr 3               ;;     let format = Math.round(value).toString(16).padStart(4,'0');
00046Cr 3               ;;     values.push('$' + format);
00046Cr 3               ;; };
00046Cr 3               ;;
00046Cr 3               ;; let items_per_row = 0x8;
00046Cr 3               ;; for (let i=0; i<(values.length/items_per_row); ++i) {
00046Cr 3               ;;     let start = i * items_per_row;
00046Cr 3               ;;     let end = (i * items_per_row) + items_per_row;
00046Cr 3               ;;     let line = values.slice(start, end).join(',')
00046Cr 3               ;;     console.log('.byte ' + line + ' ; range ' +  start.toString(16) + ' to ' + (end-1).toString(16));
00046Cr 3               ;; }
00046Cr 3               ;
00046Cr 3               ; ---------------------------------------------------------------------------
00046Cr 3               RecalculateSockfolder:
00046Cr 3                   @DataTemp = $4                               ; temp value used for some maths
00046Cr 3                   @DataSubX = $2                               ; sockfolder subpixel x value
00046Cr 3                   @DataX    = $3                               ; sockfolder pixel x value
00046Cr 3  AD 00 04         lda SprObject_X_MoveForce                    ; get subpixel x position
00046Fr 3  85 02            sta @DataSubX                                ; and store it in our temp data
000471r 3  A5 86            lda Player_X_Position                        ; get x position
000473r 3  85 03            sta @DataX                                   ; and store it in our temp data
000475r 3  A5 CE            lda Player_Y_Position                        ; get y position
000477r 3  49 FF            eor #$FF                                     ; invert the bits, now $FF is the top of the screen
000479r 3  4A               lsr a                                        ; divide pixel position by 8
00047Ar 3  4A               lsr a                                        ;
00047Br 3  4A               lsr a                                        ;
00047Cr 3  90 0F            bcc @sock1                                   ; if we're on the top half of tile 'tile', we will land 2.5 pixels later.
00047Er 3  48               pha                                          ; so store the current value
00047Fr 3  18               clc                                          ;
000480r 3  A5 02            lda @DataSubX                                ; get subpixel x position
000482r 3  69 80            adc #$80                                     ; and increase it by half
000484r 3  85 02            sta @DataSubX                                ; and store it back
000486r 3  A5 03            lda @DataX                                   ; get x position
000488r 3  69 02            adc #$02                                     ; and add 2 + carry value
00048Ar 3  85 03            sta @DataX                                   ; and store it back
00048Cr 3  68               pla                                          ; then restore our original value
00048Dr 3               @sock1:                                          ;
00048Dr 3  85 04            sta @DataTemp                                ; store this in our temp value
00048Fr 3  0A               asl a                                        ; multiply by 4
000490r 3  0A               asl a                                        ;
000491r 3  65 04            adc @DataTemp                                ; and add the temp value
000493r 3  65 03            adc @DataX                                   ; then add our x position
000495r 3  85 03            sta @DataX                                   ; and store it back
000497r 3  60               rts                                          ;
000498r 3               ; ===========================================================================
000498r 3               
000498r 2               .include "menu.asm"
000498r 3               SettablesCount   = $6
000498r 3               MenuTextPtr      = $C3
000498r 3               MenuTextLen      = $C2
000498r 3               
000498r 3               .pushseg
000498r 3               .segment "MENUWRAM"
00000Ar 3  00           MenuSelectedItem: .byte $00
00000Br 3  00           MenuSelectedSubitem: .byte $00
00000Cr 3               Settables:
00000Cr 3  00           SettablesWorld: .byte $00
00000Dr 3  00           SettablesLevel: .byte $00
00000Er 3  00           SettablesPUP:   .byte $00
00000Fr 3  00           SettablesHero:  .byte $00
000010r 3  00           SettablesW9:    .byte $00
000011r 3  00           SettablesRule:  .byte $00
000012r 3               .popseg
000498r 3               
000498r 3               ; names for each selection type
000498r 3               MenuTitles:
000498r 3  20 18 1B 15  .byte "WORLD   "
00049Cr 3  0D 24 24 24  
0004A0r 3  15 0E 1F 0E  .byte "LEVEL   "
0004A4r 3  15 24 24 24  
0004A8r 3  19 28 1E 19  .byte "P-UP    "
0004ACr 3  24 24 24 24  
0004B0r 3  11 0E 1B 18  .byte "HERO    "
0004B4r 3  24 24 24 24  
0004B8r 3  20 09 24 18  .byte "W9 ON   "
0004BCr 3  17 24 24 24  
0004C0r 3  1B 1E 15 0E  .byte "RULE    "
0004C4r 3  24 24 24 24  
0004C8r 3               
0004C8r 3               ; ppu position to draw each title
0004C8r 3               .define MenuTitleLocations \
0004C8r 3                   $20CA + ($40 * 0), \
0004C8r 3                   $20CA + ($40 * 1), \
0004C8r 3                   $20CA + ($40 * 2), \
0004C8r 3                   $20CA + ($40 * 3), \
0004C8r 3                   $20CA + ($40 * 4), \
0004C8r 3                   $20CA + ($40 * 5)
0004C8r 3               
0004C8r 3               ; ppu position to draw each value
0004C8r 3               .define MenuValueLocations \
0004C8r 3                   $20D3 + ($40 * 0) - 0, \
0004C8r 3                   $20D3 + ($40 * 1) - 0, \
0004C8r 3                   $20D3 + ($40 * 2) - 3, \
0004C8r 3                   $20D3 + ($40 * 3) - 3, \
0004C8r 3                   $20D3 + ($40 * 4) - 2, \
0004C8r 3                   $20D3 + ($40 * 5) - 3
0004C8r 3               
0004C8r 3               ; which routines to use to change each menu items value
0004C8r 3               UpdateSelectedValueJE:
0004C8r 3  98               tya
0004C9r 3  20 rr rr         jsr JumpEngine
0004CCr 3  rr rr            .word UpdateValueWorldNumber ; world
0004CEr 3  rr rr            .word UpdateValueLevelNumber ; level
0004D0r 3  rr rr            .word UpdateValuePUps        ; p-up
0004D2r 3  rr rr            .word UpdateValueToggle      ; hero
0004D4r 3  rr rr            .word UpdateValueToggle      ; world 9
0004D6r 3  rr rr            .word UpdateValueFramerule   ; framerule
0004D8r 3               
0004D8r 3               ; which routines to use to draw each menu items value
0004D8r 3               DrawMenuValueJE:
0004D8r 3  98               tya
0004D9r 3  20 rr rr         jsr JumpEngine
0004DCr 3  rr rr            .word DrawValueWorld         ; world
0004DEr 3  rr rr            .word DrawValueNumber        ; level
0004E0r 3  rr rr            .word DrawValueString_PUp    ; p-up
0004E2r 3  rr rr            .word DrawValueString_Hero   ; hero
0004E4r 3  rr rr            .word DrawValueString_W9     ; world 9
0004E6r 3  rr rr            .word DrawValueFramerule     ; framerule
0004E8r 3               
0004E8r 3               ; ===========================================================================
0004E8r 3               ;  Redraw menu
0004E8r 3               ; ---------------------------------------------------------------------------
0004E8r 3               DrawMenu:
0004E8r 3               MenuReset:
0004E8r 3                   @Temp = $10
0004E8r 3  A0 05            ldy #(SettablesCount-1)                  ; get number of menu items
0004EAr 3  84 10        :   sty @Temp                                ; store the current menu item
0004ECr 3  20 rr rr         jsr @DrawMenuTitle                       ; draw the title of the menu item
0004EFr 3  A4 10            ldy @Temp                                ; restore the menu item
0004F1r 3  20 rr rr         jsr DrawMenuValueJE                      ; draw the value of the menu item
0004F4r 3  A4 10            ldy @Temp                                ; restore the menu item
0004F6r 3  88               dey                                      ; and decrement it
0004F7r 3  10 F1            bpl :-                                   ; if not done, keep drawing
0004F9r 3  60               rts                                      ; otherwise, exit
0004FAr 3               @DrawMenuTitle:
0004FAr 3  18               clc                                      ;
0004FBr 3  AD 00 03         lda VRAM_Buffer1_Offset                  ; get current vram offset position
0004FEr 3  AA               tax                                      ;
0004FFr 3  69 08            adc #3+5                                 ; advance it based on how many bytes we will write
000501r 3  8D 00 03         sta VRAM_Buffer1_Offset                  ; and save it back
000504r 3  B9 rr rr         lda MenuTitleLocationsHi,y               ; set ppu location of the current item's title
000507r 3  9D 01 03         sta VRAM_Buffer1+0,x                     ;
00050Ar 3  B9 rr rr         lda MenuTitleLocationsLo,y               ;
00050Dr 3  9D 02 03         sta VRAM_Buffer1+1,x                     ;
000510r 3  A9 05            lda #5                                   ; store length of the title
000512r 3  9D 03 03         sta VRAM_Buffer1+2,x                     ;
000515r 3  98               tya                                      ; copy the menu item index to A
000516r 3  2A               rol a                                    ; and multiply it by 8, the offsets of the title strings
000517r 3  2A               rol a                                    ;
000518r 3  2A               rol a                                    ;
000519r 3  A8               tay                                      ; and copy that back to Y
00051Ar 3  B9 rr rr         lda MenuTitles+0,y                       ; then write the title screen to the buffer
00051Dr 3  9D 04 03         sta VRAM_Buffer1+3,x                     ;
000520r 3  B9 rr rr         lda MenuTitles+1,y                       ;
000523r 3  9D 05 03         sta VRAM_Buffer1+4,x                     ;
000526r 3  B9 rr rr         lda MenuTitles+2,y                       ;
000529r 3  9D 06 03         sta VRAM_Buffer1+5,x                     ;
00052Cr 3  B9 rr rr         lda MenuTitles+3,y                       ;
00052Fr 3  9D 07 03         sta VRAM_Buffer1+6,x                     ;
000532r 3  B9 rr rr         lda MenuTitles+4,y                       ;
000535r 3  9D 08 03         sta VRAM_Buffer1+7,x                     ;
000538r 3  A9 00            lda #0                                   ; and end the buffer with null
00053Ar 3  9D 09 03         sta VRAM_Buffer1+8,x                     ;
00053Dr 3  60               rts                                      ;
00053Er 3               ; ===========================================================================
00053Er 3               
00053Er 3               ; ===========================================================================
00053Er 3               ;  Menu main loop
00053Er 3               ; ---------------------------------------------------------------------------
00053Er 3               MenuNMI:
00053Er 3  20 rr rr         jsr DrawSelectionMarkers                 ; reposition the selection markers
000541r 3  18               clc                                      ;
000542r 3  AD rr rr         lda PressedButtons                       ; check current inputs
000545r 3  D0 01            bne @READINPUT                           ; if any buttons are held, check them
000547r 3  60               rts                                      ; otherwise there's nothing to do
000548r 3               @READINPUT:                                  ;
000548r 3  29 0F            and #Right_Dir|Left_Dir|Down_Dir|Up_Dir  ; are we holding a direction?
00054Ar 3  F0 09            beq @SELECT                              ; if not, check for select
00054Cr 3  AC rr rr         ldy MenuSelectedItem                     ; we are, get the current selected item
00054Fr 3  20 rr rr         jsr UpdateSelectedValueJE                ; update the value
000552r 3  4C rr rr         jmp @RenderMenu                          ; redraw the menu and exit
000555r 3               @SELECT:                                     ;
000555r 3  AD rr rr         lda PressedButtons                       ; check current inputs
000558r 3  C9 20            cmp #Select_Button                       ; are we holding select?
00055Ar 3  D0 13            bne @START                               ; if not, check for start
00055Cr 3  A2 00            ldx #0                                   ; we are changing selected menu item
00055Er 3  8E rr rr         stx MenuSelectedSubitem                  ; clear selected subitem
000561r 3  EE rr rr         inc MenuSelectedItem                     ; and advance to the next item
000564r 3  AD rr rr         lda MenuSelectedItem                     ; then check if we've reached the final item
000567r 3  C9 06            cmp #SettablesCount                      ;
000569r 3  D0 03            bne :+                                   ; no - skip ahead
00056Br 3  8E rr rr         stx MenuSelectedItem                     ; yes - clear the selected item
00056Er 3  60           :   rts                                      ; and exit
00056Fr 3               @START:                                      ;
00056Fr 3  C9 10            cmp #Start_Button                        ; are we holding start?
000571r 3  D0 17            bne @DONE                                ; no - nothing to do, exit
000573r 3  A9 00            lda #0                                   ; yes - check held buttons
000575r 3  AE rr rr         ldx HeldButtons                          ;
000578r 3  E0 80            cpx #A_Button                            ; check if we're holding A
00057Ar 3  90 02            bcc :+                                   ; nope - skip ahead
00057Cr 3  A9 01            lda #1                                   ; yes - set flag for 122 frame offset
00057Er 3  8D 0B 60     :   sta IncrementRNG_122                     ; save 122 frame offset flag
000581r 3  4C rr rr         jmp TStartGame                           ; and start the game
000584r 3               @RenderMenu:                                 ;
000584r 3  AC rr rr         ldy MenuSelectedItem                     ; get the current selected item
000587r 3  20 rr rr         jsr DrawMenu                             ; and redraw it
00058Ar 3               @DONE:                                       ;
00058Ar 3  60               rts                                      ; done
00058Br 3               ; ===========================================================================
00058Br 3               
00058Br 3               
00058Br 3               ; ===========================================================================
00058Br 3               ;  Position the "cursors" of the menu at the correct location
00058Br 3               ; ---------------------------------------------------------------------------
00058Br 3               DrawSelectionMarkers:
00058Br 3  A9 00            lda #$00                                 ; set palette attributes for sprites
00058Dr 3  8D 06 02         sta Sprite_Attributes + (1 * SpriteLen)  ;
000590r 3  A9 21            lda #$21                                 ;
000592r 3  8D 0A 02         sta Sprite_Attributes + (2 * SpriteLen)  ;
000595r 3  A9 5B            lda #$5B                                 ; mushroom elevator for sprite 1
000597r 3  8D 05 02         sta Sprite_Tilenumber + (1 * SpriteLen)  ;
00059Ar 3  A9 27            lda #$27                                 ; set solid background for sprite 2
00059Cr 3  8D 09 02         sta Sprite_Tilenumber + (2 * SpriteLen)  ;
00059Fr 3  A9 1E            lda #$1E                                 ; get initial Y position
0005A1r 3  AC rr rr         ldy MenuSelectedItem                     ; get current menu item
0005A4r 3  18           :   clc                                      ;
0005A5r 3  69 10            adc #$10                                 ; add 16px per menu item
0005A7r 3  88               dey                                      ; decrement loop value
0005A8r 3  10 FA            bpl :-                                   ; and loop until done
0005AAr 3  8D 04 02         sta Sprite_Y_Position + (1 * SpriteLen)  ; reposition sprite 1 (floating coin)
0005ADr 3  8D 08 02         sta Sprite_Y_Position + (2 * SpriteLen)  ; reposition sprite 2 (background color)
0005B0r 3  A9 A9            lda #$A9                                 ; get initial X position
0005B2r 3  8D 07 02         sta Sprite_X_Position + (1 * SpriteLen)  ; reposition sprite 1 (floating coin)
0005B5r 3  E9 08            sbc #$8                                  ; offset by 8px for the background color
0005B7r 3  AC rr rr         ldy MenuSelectedSubitem                  ; get which subitem is selected
0005BAr 3  38           :   sec                                      ; then offset by another 8px per subitem
0005BBr 3  E9 08            sbc #$8                                  ;
0005BDr 3  88               dey                                      ; decrement loop value
0005BEr 3  10 FA            bpl :-                                   ; and loop until done
0005C0r 3  8D 0B 02         sta Sprite_X_Position + (2 * SpriteLen)  ; reposition sprite 2 (background color)
0005C3r 3  60               rts                                      ; done
0005C4r 3               ; ===========================================================================
0005C4r 3               
0005C4r 3               ; update selected world value
0005C4r 3               UpdateValueWorldNumber:
0005C4r 3  AE rr rr         ldx WorldCount         ; get number of worlds
0005C7r 3  AD rr rr         lda HeldButtons        ; check held buttons
0005CAr 3  29 40            and #B_Button          ; are we holding B?
0005CCr 3  F0 02            beq :+                 ; no - skip ahead
0005CEr 3  A2 FF            ldx #$FF               ; otherwise allow selecting any value
0005D0r 3  4C rr rr     :   jmp UpdateValueShared  ; update selected menu item
0005D3r 3               
0005D3r 3               ; update selected level value
0005D3r 3               UpdateValueLevelNumber:
0005D3r 3  AE rr rr         ldx LevelCount         ; get number of levels per world
0005D6r 3  AD rr rr         lda HeldButtons        ; check held buttons
0005D9r 3  29 40            and #B_Button          ; are we holding B?
0005DBr 3  F0 02            beq :+                 ; no - skip ahead
0005DDr 3  A2 FF            ldx #$FF               ; otherwise allow selecting any value
0005DFr 3  4C rr rr     :   jmp UpdateValueShared  ; update selected menu item
0005E2r 3               
0005E2r 3               ; update selected powerup value
0005E2r 3               UpdateValuePUps:
0005E2r 3  A2 06            ldx #6                 ; there are 6 total states
0005E4r 3  4C rr rr         jmp UpdateValueShared  ; update selected menu item
0005E7r 3               
0005E7r 3               ; update toggleable option
0005E7r 3               UpdateValueToggle:
0005E7r 3  A2 02            ldx #2                 ; toggle between two options
0005E9r 3  4C rr rr         jmp UpdateValueShared  ; update selected menu item
0005ECr 3               
0005ECr 3               ; ===========================================================================
0005ECr 3               ; Update a single byte menu item
0005ECr 3               ; ---------------------------------------------------------------------------
0005ECr 3               ; Input:  Y   = menu item index
0005ECr 3               ;         X   = maximum allowed value
0005ECr 3               ; ---------------------------------------------------------------------------
0005ECr 3               UpdateValueShared:
0005ECr 3                   @Max = $0
0005ECr 3  86 00            stx @Max                          ; temp store max value
0005EEr 3  18               clc                               ;
0005EFr 3  AD rr rr         lda PressedButtons                ; get current inputs
0005F2r 3  29 06            and #Down_Dir|Left_Dir            ; check if we're pressing decrementing direction
0005F4r 3  D0 0D            bne @Decrement                    ; yes - skip ahead to decrement
0005F6r 3               @Increment:                           ; no - we are incrementing
0005F6r 3  B9 rr rr         lda Settables,y                   ; get current value of the menu item
0005F9r 3  69 01            adc #1                            ; increment it
0005FBr 3  C5 00            cmp @Max                          ; check if we're beyond the maximum value
0005FDr 3  90 13            bcc @Store                        ; no - skip ahead to store
0005FFr 3  A9 00            lda #0                            ; yes - set to 0
000601r 3  F0 0F            beq @Store                        ; and store
000603r 3               @Decrement:                           ;
000603r 3  B9 rr rr         lda Settables,y                   ; get current value of the menu item
000606r 3  F0 05            beq @Wrap                         ; if it's 0, wrap around
000608r 3  38               sec                               ;
000609r 3  E9 01            sbc #1                            ; otherwise, decrement it
00060Br 3  50 05            bvc @Store                        ; skip ahead to store
00060Dr 3               @Wrap:                                ;
00060Dr 3  A5 00            lda @Max                          ; wrap around to the maximum value + 1
00060Fr 3  38               sec                               ; and decrement it by 1
000610r 3  E9 01            sbc #1                            ;
000612r 3               @Store:                               ;
000612r 3  99 rr rr         sta Settables,y                   ; store the new value
000615r 3  60               rts                               ;
000616r 3               ; ===========================================================================
000616r 3               
000616r 3               ; ===========================================================================
000616r 3               ; Modify the selected framerule
000616r 3               ; ---------------------------------------------------------------------------
000616r 3               UpdateValueFramerule:
000616r 3  18               clc                               ;
000617r 3  AE rr rr         ldx MenuSelectedSubitem           ; get selected digit offset
00061Ar 3  AD rr rr         lda PressedButtons                ; check inputs
00061Dr 3  29 03            and #Right_Dir|Left_Dir           ; are we pressing left/right
00061Fr 3  F0 11            beq @update_value                 ; no - skip to check if we're changing value
000621r 3  CA               dex                               ; yes - we are changing which digit is selected
000622r 3  AD rr rr         lda PressedButtons                ; get buttons again
000625r 3  C9 01            cmp #Right_Dir                    ; are we pressing right?
000627r 3  F0 02            beq @store_selected               ; yes - store X as new selected digit
000629r 3  E8               inx                               ; no - we are pressing left, increment twice to offset dex
00062Ar 3  E8               inx                               ;
00062Br 3               @store_selected:                      ;
00062Br 3  8A               txa                               ;
00062Cr 3  29 03            and #%11                          ; mask to valid framerule value
00062Er 3  8D rr rr         sta MenuSelectedSubitem           ; and update selected digit
000631r 3  60               rts                               ; done - exit
000632r 3               @update_value:
000632r 3  BC rr rr         ldy MathFrameruleDigitStart,x     ; get the digit we're changing
000635r 3  AD rr rr         lda PressedButtons                ; and check inputs
000638r 3  C9 08            cmp #Up_Dir                       ; are we pressing up?
00063Ar 3  F0 07            beq @increase                     ; yes - increment digit
00063Cr 3  88               dey                               ; no - decrement digit
00063Dr 3  10 0B            bpl @store_value                  ; if we didn't underflow, store value
00063Fr 3  A0 09            ldy #9                            ; otherwise wrap back around to 9
000641r 3  D0 07            bne @store_value                  ; and store value
000643r 3               @increase:
000643r 3  C8               iny                               ; we're increment, so, increment Y
000644r 3  C0 0A            cpy #$A                           ; check if we overflowed
000646r 3  D0 02            bne @store_value                  ; no - store value
000648r 3  A0 00            ldy #0                            ; yes - wrap back around to 0
00064Ar 3               @store_value:
00064Ar 3  98               tya                               ;
00064Br 3  9D rr rr         sta MathFrameruleDigitStart,x     ; and save the new digit
00064Er 3  60               rts                               ; exit!
00064Fr 3               ; ===========================================================================
00064Fr 3               
00064Fr 3               ; ===========================================================================
00064Fr 3               ; Draws a menu item to screen
00064Fr 3               ; ---------------------------------------------------------------------------
00064Fr 3               DrawValueWorld:
00064Fr 3  18               clc                               ;
000650r 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
000653r 3  AA               tax                               ;
000654r 3  69 05            adc #5                            ; offset it based on how much we're writing
000656r 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
000659r 3  B9 rr rr         lda MenuValueLocationsHi,y        ; get the ppu location of this menu item, and write to vram buffer
00065Cr 3  9D 01 03         sta VRAM_Buffer1+0,x              ;
00065Fr 3  B9 rr rr         lda MenuValueLocationsLo,y        ;
000662r 3  9D 02 03         sta VRAM_Buffer1+1,x              ;
000665r 3  A9 02            lda #2                            ; we're writing 1 number and possibly an indicator
000667r 3  9D 03 03         sta VRAM_Buffer1+2,x              ;
00066Ar 3  B9 rr rr         lda Settables,y                   ; get the value of the settable item
00066Dr 3  48               pha                               ; push to the stack so we can use it later
00066Er 3  69 01            adc #1                            ; increment it, since we display 1-based numbers
000670r 3  C9 0A            cmp #$0a                          ; have we selected a 2J world?
000672r 3  90 02            bcc @DrawWorldNum                 ; no, draw world number as-is
000674r 3  E9 09            sbc #$09                          ; otherwise subtract 9 for display
000676r 3               @DrawWorldNum:                        ;
000676r 3  9D 04 03         sta VRAM_Buffer1+3,x              ; store the number to be drawn
000679r 3  68               pla                               ; get the value of the settable item again
00067Ar 3  C9 09            cmp #$09                          ; did we select a 2J world?
00067Cr 3  90 04            bcc @NoStarIcon                   ; no, put blank space instead of star icon
00067Er 3  A9 9F            lda #$9f                          ; otherwise print a star to indicate 2J worlds
000680r 3  D0 02            bne @StoreStarIcon                ; branch ahead
000682r 3               @NoStarIcon:                          ;
000682r 3  A9 24            lda #$24                          ; blank space ID
000684r 3               @StoreStarIcon:                       ;
000684r 3  9D 05 03         sta VRAM_Buffer1+4,x              ; store star icon/blank space here
000687r 3  A9 00            lda #0                            ; and mark the end of the buffer
000689r 3  9D 06 03         sta VRAM_Buffer1+5,x              ;
00068Cr 3  60               rts                               ;
00068Dr 3               ; ===========================================================================
00068Dr 3               
00068Dr 3               ; ===========================================================================
00068Dr 3               ; Draws a menu item to screen
00068Dr 3               ; ---------------------------------------------------------------------------
00068Dr 3               DrawValueNumber:
00068Dr 3  18               clc                               ;
00068Er 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
000691r 3  AA               tax                               ;
000692r 3  69 04            adc #4                            ; offset it based on how much we're writing
000694r 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
000697r 3  B9 rr rr         lda MenuValueLocationsHi,y        ; get the ppu location of this menu item, and write to vram buffer
00069Ar 3  9D 01 03         sta VRAM_Buffer1+0,x              ;
00069Dr 3  B9 rr rr         lda MenuValueLocationsLo,y        ;
0006A0r 3  9D 02 03         sta VRAM_Buffer1+1,x              ;
0006A3r 3  A9 01            lda #1                            ; we're writing 1 number
0006A5r 3  9D 03 03         sta VRAM_Buffer1+2,x              ;
0006A8r 3  B9 rr rr         lda Settables,y                   ; get the value of the settable item
0006ABr 3  69 01            adc #1                            ; and increment it, since we display 1-based numbers
0006ADr 3  9D 04 03         sta VRAM_Buffer1+3,x              ; store the number to be drawn
0006B0r 3  A9 00            lda #0                            ; and mark the end of the buffer
0006B2r 3  9D 05 03         sta VRAM_Buffer1+4,x              ;
0006B5r 3  60               rts                               ;
0006B6r 3               ; ===========================================================================
0006B6r 3               
0006B6r 3               ; ===========================================================================
0006B6r 3               ; Draws the four digit framerule to screen
0006B6r 3               ; ---------------------------------------------------------------------------
0006B6r 3               DrawValueFramerule:
0006B6r 3  18               clc                               ;
0006B7r 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
0006BAr 3  AA               tax                               ;
0006BBr 3  69 07            adc #7                            ; offset it based on how much we're writing
0006BDr 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
0006C0r 3  B9 rr rr         lda MenuValueLocationsHi, y       ; get the ppu location of this menu item, and write to vram buffer
0006C3r 3  9D 01 03         sta VRAM_Buffer1+0, x             ;
0006C6r 3  B9 rr rr         lda MenuValueLocationsLo, y       ;
0006C9r 3  9D 02 03         sta VRAM_Buffer1+1, x             ;
0006CCr 3  A9 04            lda #4                            ; we're writing 4 numbers
0006CEr 3  9D 03 03         sta VRAM_Buffer1+2, x             ;
0006D1r 3  AD rr rr         lda MathFrameruleDigitStart+0     ; copy each of the four digits to vram buffer
0006D4r 3  9D 07 03         sta VRAM_Buffer1+3+3, x           ;
0006D7r 3  AD rr rr         lda MathFrameruleDigitStart+1     ;
0006DAr 3  9D 06 03         sta VRAM_Buffer1+3+2, x           ;
0006DDr 3  AD rr rr         lda MathFrameruleDigitStart+2     ;
0006E0r 3  9D 05 03         sta VRAM_Buffer1+3+1, x           ;
0006E3r 3  AD rr rr         lda MathFrameruleDigitStart+3     ;
0006E6r 3  9D 04 03         sta VRAM_Buffer1+3+0, x           ;
0006E9r 3  A9 00            lda #0                            ; and mark the end of the buffer
0006EBr 3  9D 08 03         sta VRAM_Buffer1+3+4, x           ;
0006EEr 3  60               rts                               ;
0006EFr 3               ; ===========================================================================
0006EFr 3               
0006EFr 3               ; ===========================================================================
0006EFr 3               ; Draws a string from a pointer to screen
0006EFr 3               ; ---------------------------------------------------------------------------
0006EFr 3               DrawValueString:
0006EFr 3  18               clc                               ;
0006F0r 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
0006F3r 3  AA               tax                               ;
0006F4r 3  65 C2            adc MenuTextLen                   ; offset it based on string length
0006F6r 3  69 03            adc #3                            ; and add 3 for the header
0006F8r 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
0006FBr 3  B9 rr rr         lda MenuValueLocationsHi,y        ; get the ppu location of this menu item, and write to vram buffer
0006FEr 3  9D 01 03         sta VRAM_Buffer1+0,x              ;
000701r 3  B9 rr rr         lda MenuValueLocationsLo,y        ;
000704r 3  9D 02 03         sta VRAM_Buffer1+1,x              ;
000707r 3  A5 C2            lda MenuTextLen                   ; write the string length to vram buffer
000709r 3  9D 03 03         sta VRAM_Buffer1+2,x              ;
00070Cr 3  A0 00            ldy #0                            ; prepare iterator
00070Er 3               @CopyNext:                            ;
00070Er 3  B1 C3            lda (MenuTextPtr),y               ; copy a byte of the string to vram
000710r 3  9D 04 03         sta VRAM_Buffer1+3,x              ;
000713r 3  E8               inx                               ; increment vram offset
000714r 3  C8               iny                               ; increment string read offset
000715r 3  C4 C2            cpy MenuTextLen                   ; check if we're done
000717r 3  90 F5            bcc @CopyNext                     ; no - copy next byte
000719r 3  A9 00            lda #0                            ; and mark the end of the buffer
00071Br 3  9D 05 03         sta VRAM_Buffer1+4, x             ;
00071Er 3  60               rts                               ;
00071Fr 3               ; ===========================================================================
00071Fr 3               
00071Fr 3               ; ===========================================================================
00071Fr 3               ; Draws a powerup state to screen
00071Fr 3               ; ---------------------------------------------------------------------------
00071Fr 3               DrawValueString_PUp:
00071Fr 3  B9 rr rr         lda Settables,y                   ; get the selected powerup state
000722r 3  0A               asl a                             ; get offset into pointer table
000723r 3  AA               tax                               ;
000724r 3  BD rr rr         lda @Strings,x                    ; copy string pointer to menu text pointer
000727r 3  85 C3            sta MenuTextPtr                   ;
000729r 3  BD rr rr         lda @Strings+1,x                  ;
00072Cr 3  85 C4            sta MenuTextPtr+1                 ;
00072Er 3  A9 05            lda #5                            ; set fixed string length
000730r 3  85 C2            sta MenuTextLen                   ;
000732r 3  4C rr rr         jmp DrawValueString               ; and draw the string
000735r 3               
000735r 3               @Strings:
000735r 3  rr rr        .word @Str0
000737r 3  rr rr        .word @Str1
000739r 3  rr rr        .word @Str2
00073Br 3  rr rr        .word @Str3
00073Dr 3  rr rr        .word @Str4
00073Fr 3  rr rr        .word @Str5
000741r 3               
000741r 3  17 18 17 0E  @Str0: .byte "NONE "
000745r 3  24           
000746r 3  24 0B 12 10  @Str1: .byte " BIG "
00074Ar 3  24           
00074Br 3  0F 12 1B 0E  @Str2: .byte "FIRE "
00074Fr 3  24           
000750r 3  17 18 17 0E  @Str3: .byte "NONE!"
000754r 3  2B           
000755r 3  24 0B 12 10  @Str4: .byte " BIG!"
000759r 3  2B           
00075Ar 3  0F 12 1B 0E  @Str5: .byte "FIRE!"
00075Er 3  2B           
00075Fr 3               ; ===========================================================================
00075Fr 3               
00075Fr 3               ; ===========================================================================
00075Fr 3               ; Draws player name to the screen
00075Fr 3               ; ---------------------------------------------------------------------------
00075Fr 3               DrawValueString_Hero:
00075Fr 3  B9 rr rr         lda Settables,y                   ; get the selected player
000762r 3  0A               asl a                             ; get offset into pointer table
000763r 3  AA               tax                               ;
000764r 3  BD rr rr         lda @Strings,x                    ; copy string pointer to menu text pointer
000767r 3  85 C3            sta MenuTextPtr                   ;
000769r 3  BD rr rr         lda @Strings+1,x                  ;
00076Cr 3  85 C4            sta MenuTextPtr+1                 ;
00076Er 3  A9 05            lda #5                            ; set fixed string length
000770r 3  85 C2            sta MenuTextLen                   ;
000772r 3  4C rr rr         jmp DrawValueString               ; and draw the string
000775r 3               
000775r 3               @Strings:
000775r 3  rr rr        .word @Str0
000777r 3  rr rr        .word @Str1
000779r 3               
000779r 3  16 0A 1B 12  @Str0: .byte "MARIO"
00077Dr 3  18           
00077Er 3  15 1E 12 10  @Str1: .byte "LUIGI"
000782r 3  12           
000783r 3               ; ===========================================================================
000783r 3               
000783r 3               ; ===========================================================================
000783r 3               ; Draws world 9 toggle to the screen
000783r 3               ; ---------------------------------------------------------------------------
000783r 3               DrawValueString_W9:
000783r 3  B9 rr rr         lda Settables,y                   ; get the value of the world 9 toggle
000786r 3  0A               asl a                             ; get offset into pointer table
000787r 3  AA               tax                               ;
000788r 3  BD rr rr         lda @Strings,x                    ; copy string pointer to menu text pointer
00078Br 3  85 C3            sta MenuTextPtr                   ;
00078Dr 3  BD rr rr         lda @Strings+1,x                  ;
000790r 3  85 C4            sta MenuTextPtr+1                 ;
000792r 3  A9 03            lda #3                            ; set fixed string length
000794r 3  85 C2            sta MenuTextLen                   ;
000796r 3  4C rr rr         jmp DrawValueString               ; and draw the string
000799r 3               
000799r 3               @Strings:
000799r 3  rr rr        .word @Str0
00079Br 3  rr rr        .word @Str1
00079Dr 3               
00079Dr 3  24 17 18     @Str0: .byte " NO"
0007A0r 3  22 0E 1C     @Str1: .byte "YES"
0007A3r 3               ; ===========================================================================
0007A3r 3               
0007A3r 3               ; pointers to menu values
0007A3r 3  D3 13 50 90  MenuValueLocationsLo: .lobytes MenuValueLocations
0007A7r 3  D1 10        
0007A9r 3  20 21 21 21  MenuValueLocationsHi: .hibytes MenuValueLocations
0007ADr 3  21 22        
0007AFr 3  CA 0A 4A 8A  MenuTitleLocationsLo: .lobytes MenuTitleLocations
0007B3r 3  CA 0A        
0007B5r 3  20 21 21 21  MenuTitleLocationsHi: .hibytes MenuTitleLocations
0007B9r 3  21 22        
0007BBr 3               
0007BBr 2               .include "utils.asm"
0007BBr 3               
0007BBr 3               ; ===========================================================================
0007BBr 3               ;  Base 10 addition
0007BBr 3               ; ---------------------------------------------------------------------------
0007BBr 3               ; Input:
0007BBr 3               ;   X - offset into base10 value list to add
0007BBr 3               ;   A - value to add
0007BBr 3               ; ---------------------------------------------------------------------------
0007BBr 3               B10Add:
0007BBr 3  18               clc                        ;
0007BCr 3  7D rr rr         adc MathDigits,x           ; add value to digit
0007BFr 3  9D rr rr         sta MathDigits,x           ; store result
0007C2r 3  C9 0A        :   cmp #10                    ; compare against 10
0007C4r 3  90 12            bcc @Done                  ; if less than 10, we're done
0007C6r 3  A9 00            lda #0                     ; otherwise, set to 0
0007C8r 3  9D rr rr         sta MathDigits,x           ; store result
0007CBr 3  E8               inx                        ; move to next digit
0007CCr 3  30 0A            bmi @Done                  ; if no more digits, we're done
0007CEr 3  BD rr rr         lda MathDigits,x           ; get next digit
0007D1r 3  69 00            adc #0                     ; add our carry
0007D3r 3  9D rr rr         sta MathDigits,x           ; store result
0007D6r 3  90 EA            bcc :-                     ; and keep going until we don't have a carry
0007D8r 3               @Done:                         ;
0007D8r 3  60               rts                        ;
0007D9r 3               ; ===========================================================================
0007D9r 3               
0007D9r 3               ; ===========================================================================
0007D9r 3               ;  Divide A value by 10
0007D9r 3               ; ---------------------------------------------------------------------------
0007D9r 3               ;  Example:
0007D9r 3               ;  lda #145
0007D9r 3               ;  jsr B10DivideBy10
0007D9r 3               ;  ; A = 5   (remainder)
0007D9r 3               ;  ; X = 14  (quotient)
0007D9r 3               ; ---------------------------------------------------------------------------
0007D9r 3               B10DivBy10:
0007D9r 3  A2 00            ldx #$00                  ; clear result
0007DBr 3  C9 0A        :   cmp #$0a                  ; compare current value against 10
0007DDr 3  90 05            bcc @Done                 ; if lower, then we are finished
0007DFr 3  E9 0A            sbc #$0a                  ; otherwise subtract 10
0007E1r 3  E8               inx                       ; and increment result
0007E2r 3  D0 F7            bne :-                    ; keep looping
0007E4r 3               @Done:                        ;
0007E4r 3  60               rts                       ; done
0007E5r 3               ; ===========================================================================
0007E5r 3               
0007E5r 3               ; ================================================================
0007E5r 3               ;  6502 multiply by 10
0007E5r 3               ; ----------------------------------------------------------------
0007E5r 3               MultiplyBy10:
0007E5r 3  0A               asl                       ; multiply by 2
0007E6r 3  85 00            sta $0                    ; store in temp value
0007E8r 3  0A               asl                       ; multiply by 4
0007E9r 3  0A               asl                       ;
0007EAr 3  18               clc                       ;
0007EBr 3  65 00            adc $0                    ; add temp value, so, (A*2*4)+(A*2)
0007EDr 3  60               rts                       ; done
0007EEr 3               ; ================================================================
0007EEr 3               
0007EEr 3               ;; copied code from smb1
0007EEr 3               WriteVRAMBufferToScreen:
0007EEr 3  AD 00 03         lda VRAM_Buffer1_Offset
0007F1r 3  F0 2F            beq @Skip
0007F3r 3  A0 03            ldy #>(VRAM_Buffer1)
0007F5r 3  84 01            sty $1
0007F7r 3  A0 01            ldy #<(VRAM_Buffer1)
0007F9r 3  84 00            sty $0
0007FBr 3  A0 00            ldy #0
0007FDr 3               @KeepWriting:
0007FDr 3  20 rr rr         jsr WriteBufferPtrToScreen
000800r 3  B1 00            lda ($0),y
000802r 3  F0 10            beq @Done
000804r 3  18               clc
000805r 3  98               tya
000806r 3  65 00            adc $0
000808r 3  85 00            sta $0
00080Ar 3  A5 01            lda $1
00080Cr 3  69 00            adc #$0
00080Er 3  85 01            sta $1
000810r 3  A0 00            ldy #0
000812r 3  50 E9            bvc @KeepWriting
000814r 3               @Done:
000814r 3  A9 00            lda #0
000816r 3  8D 01 03         sta VRAM_Buffer1
000819r 3  8D 00 03         sta VRAM_Buffer1_Offset
00081Cr 3  8D 05 20         sta PPU_SCROLL_REG
00081Fr 3  8D 05 20         sta PPU_SCROLL_REG
000822r 3               @Skip:
000822r 3  60               rts
000823r 3               
000823r 3               WriteBufferPtrToScreen:
000823r 3  B1 00            lda ($0),y
000825r 3  C9 1F            cmp #$1F
000827r 3  90 19            bcc @Done
000829r 3  8D 06 20         sta PPU_ADDRESS
00082Cr 3  C8               iny
00082Dr 3  B1 00            lda ($0),y
00082Fr 3  8D 06 20         sta PPU_ADDRESS
000832r 3  C8               iny
000833r 3  B1 00            lda ($0),y
000835r 3  AA               tax
000836r 3  F0 0A            beq @Done
000838r 3               @Continue:
000838r 3  C8               iny
000839r 3  B1 00            lda ($0),y
00083Br 3  8D 07 20         sta PPU_DATA
00083Er 3  CA               dex
00083Fr 3  D0 F7            bne @Continue
000841r 3  C8               iny
000842r 3               @Done:
000842r 3  60               rts
000843r 3               
000843r 3               ReadJoypadsCurrent:
000843r 3  A9 01            lda #$01
000845r 3  8D 16 40         sta JOYPAD_PORT
000848r 3  8D rr rr         sta HeldButtons
00084Br 3  4A               lsr a
00084Cr 3  8D 16 40         sta JOYPAD_PORT
00084Fr 3               @KeepReading:
00084Fr 3  AD 16 40         lda JOYPAD_PORT
000852r 3  4A               lsr a
000853r 3  2E rr rr         rol HeldButtons
000856r 3  90 F7            bcc @KeepReading
000858r 3  60               rts
000859r 3               
000859r 3               ReadJoypads:
000859r 3  20 rr rr         jsr ReadJoypadsCurrent
00085Cr 3  AD rr rr         lda HeldButtons
00085Fr 3  49 FF            eor #%11111111
000861r 3  2D rr rr         and LastReadButtons
000864r 3  8D rr rr         sta ReleasedButtons
000867r 3  AD rr rr         lda LastReadButtons
00086Ar 3  49 FF            eor #%11111111
00086Cr 3  2D rr rr         and HeldButtons
00086Fr 3  8D rr rr         sta PressedButtons
000872r 3  AD rr rr         lda HeldButtons
000875r 3  8D rr rr         sta LastReadButtons
000878r 3  60               rts
000879r 3               
000879r 3               JumpEngine:
000879r 3  84 00            sty $00
00087Br 3  0A               asl          ;shift bit from contents of A
00087Cr 3  A8               tay
00087Dr 3  68               pla          ;pull saved return address from stack
00087Er 3  85 04            sta $04      ;save to indirect
000880r 3  68               pla
000881r 3  85 05            sta $05
000883r 3  C8               iny
000884r 3  B1 04            lda ($04),y  ;load pointer from indirect
000886r 3  85 06            sta $06      ;note that if an RTS is performed in next routine
000888r 3  C8               iny          ;it will return to the execution before the sub
000889r 3  B1 04            lda ($04),y  ;that called this routine
00088Br 3  85 07            sta $07
00088Dr 3  88               dey
00088Er 3  88               dey
00088Fr 3  98               tya
000890r 3  A4 00            ldy $00
000892r 3  6C 06 00         jmp ($06)    ;jump to the address we loaded
000895r 3               
000895r 3               
000895r 2               .include "background.asm"
000895r 3               BGDATA:
000895r 3  24 24 24 24  .incbin "../scripts/graphics/menu.bin"
000899r 3  24 24 24 24  
00089Dr 3  24 24 24 24  
000C55r 3               
000C55r 3               ; attributes
000C55r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000C59r 3  FF FF FF FF  
000C5Dr 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000C61r 3  FF FF FF FF  
000C65r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000C69r 3  FF FF FF FF  
000C6Dr 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000C71r 3  FF FF FF FF  
000C75r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $00, $00, $00
000C79r 3  FF 00 00 00  
000C7Dr 3  00 00 40 50  .byte $00, $00, $40, $50, $50, $50, $00, $00
000C81r 3  50 50 00 00  
000C85r 3  00 00 04 05  .byte $00, $00, $04, $05, $05, $05, $00, $00
000C89r 3  05 05 00 00  
000C8Dr 3  00 00 00 00  .byte $00, $00, $00, $00, $00, $00, $00, $00
000C91r 3  00 00 00 00  
000C95r 3               
000C95r 3               MenuPalette:
000C95r 3  0F 30 10 00  .byte $0F, $30, $10, $00
000C99r 3  0F 11 01 02  .byte $0F, $11, $01, $02
000C9Dr 3  0F 30 10 00  .byte $0F, $30, $10, $00
000CA1r 3  0F 30 2D 00  .byte $0F, $30, $2D, $00
000CA5r 3               
000CA5r 3  0F 16 30 27  .byte $0F, $16, $30, $27
000CA9r 3  0F 11 11 11  .byte $0F, $11, $11, $11
000CADr 3  0F 0F 10 0F  .byte $0F, $0F, $10, $0F
000CB1r 3  0F 0F 10 0F  .byte $0F, $0F, $10, $0F
000CB5r 3               MenuPaletteEnd:
000CB5r 3               
000CB5r 2               .include "bankswitching.asm"
000CB5r 3               .import __PRACTISE_WRAMCODE_LOAD__, __PRACTISE_WRAMCODE_RUN__, __PRACTISE_WRAMCODE_SIZE__
000CB5r 3               
000CB5r 3               
000CB5r 3               ; ===========================================================================
000CB5r 3               ;  Copy bankswitching code to WRAM
000CB5r 3               ; ---------------------------------------------------------------------------
000CB5r 3               InitBankSwitchingCode:
000CB5r 3  A2 00            ldx #0                                    ; init X
000CB7r 3  BD rr rr     :   lda __PRACTISE_WRAMCODE_LOAD__,x          ; load byte from ROM
000CBAr 3  9D rr rr         sta __PRACTISE_WRAMCODE_RUN__,x           ; and copy to WRAM
000CBDr 3  BD rr rr         lda __PRACTISE_WRAMCODE_LOAD__+$100,x     ; load byte from ROM
000CC0r 3  9D rr rr         sta __PRACTISE_WRAMCODE_RUN__+$100,x      ; and copy to WRAM
000CC3r 3  E8               inx                                       ; increment to copy full page
000CC4r 3  D0 F1            bne :-                                    ;
000CC6r 3  60               rts                                       ;
000CC7r 3               ; ===========================================================================
000CC7r 3               
000CC7r 3               ; this code is copied into WRAM and used to jump between banks
000CC7r 3               .pushseg
000CC7r 3               .segment "PRACTISE_WRAMCODE"
000000r 3               ; export symbols so that we can call them from smb1 and title screen as needed
000000r 3               .export BANK_PractiseNMI
000000r 3               .export BANK_PractiseReset
000000r 3               .export BANK_PractiseWriteBottomStatusLine
000000r 3               .export BANK_PractiseWriteTopStatusLine
000000r 3               .export BANK_PractisePrintScore
000000r 3               .export BANK_PractiseEnterStage
000000r 3               
000000r 3               ; these values can get replaced during patching
000000r 3  16           WorldCount: .byte 22
000001r 3  04           LevelCount: .byte 4
000002r 3  4C rr rr     RELOCATE_GetAreaDataAddrs: jmp GetAreaDataAddrs
000005r 3  4C rr rr     RELOCATE_LoadAreaPointer: jmp LoadAreaPointer
000008r 3  4C rr rr     RELOCATE_PlayerEndWorld: jmp EndWorld1Thru7
00000Br 3  4C rr rr     RELOCATE_NonMaskableInterrupt: jmp NMIHandler
00000Er 3  4C rr rr     RELOCATE_GL_ENTER: jmp GL_ENTER
000011r 3               
000011r 3               ; wrappers around some title screen routines to be called from the game
000011r 3               BANK_PractiseNMI:
000011r 3  20 rr rr     jsr BANK_TITLE_RTS
000014r 3  20 rr rr     jsr PractiseNMI
000017r 3  4C rr rr     jmp BANK_GAME_RTS
00001Ar 3               
00001Ar 3               BANK_PractiseReset:
00001Ar 3  20 rr rr     jsr BANK_TITLE_RTS
00001Dr 3  4C rr rr     jmp HotReset
000020r 3               
000020r 3               BANK_PractiseWriteBottomStatusLine:
000020r 3  20 rr rr     jsr BANK_TITLE_RTS
000023r 3  20 rr rr     jsr PractiseWriteBottomStatusLine
000026r 3  4C rr rr     jmp BANK_GAME_RTS
000029r 3               
000029r 3               BANK_PractiseWriteTopStatusLine:
000029r 3  20 rr rr     jsr BANK_TITLE_RTS
00002Cr 3  20 rr rr     jsr PractiseWriteTopStatusLine
00002Fr 3  4C rr rr     jmp BANK_GAME_RTS
000032r 3               
000032r 3               BANK_PractisePrintScore:
000032r 3  20 rr rr     jsr BANK_TITLE_RTS
000035r 3  20 rr rr     jsr RedrawLowFreqStatusbar
000038r 3  4C rr rr     jmp BANK_GAME_RTS
00003Br 3               
00003Br 3               BANK_PractiseEnterStage:
00003Br 3  20 rr rr     jsr BANK_TITLE_RTS
00003Er 3  20 rr rr     jsr PractiseEnterStage
000041r 3  4C rr rr     jmp BANK_GAME_RTS
000044r 3  60           rts
000045r 3               
000045r 3               ; ===========================================================================
000045r 3               ;  Attempt to find the level selected on the menu screen
000045r 3               ; ---------------------------------------------------------------------------
000045r 3               BANK_AdvanceToLevel:
000045r 3  AD 5F 07         lda WorldNumber                     ; check selected world number
000048r 3  C9 09            cmp #$09                            ; did we select a 2J world?
00004Ar 3  90 05            bcc @SMB1Levels                     ; if not, branch ahead to store world
00004Cr 3  EE FB 07         inc HardWorldFlag                   ; otherwise increment flag for 2J levels
00004Fr 3  E9 09            sbc #$09                            ; subtract world number by 9 to correctly store
000051r 3               @SMB1Levels:
000051r 3  8D 5F 07         sta WorldNumber                     ; store the result in the world number
000054r 3  C9 09            cmp #$09                            ; did we select a letter world?
000056r 3  90 03            bcc @NumberWorlds                   ; if not, branch ahead
000058r 3  EE 6A 07         inc PrimaryHardMode                 ; otherwise set hard mode for letter worlds
00005Br 3               @NumberWorlds:
00005Br 3  20 rr rr         jsr BANK_LEVELBANK_RTS              ; switch to the level banks
00005Er 3                   @AreaNumber = $0                    ;
00005Er 3  A2 00            ldx #0                              ;
000060r 3  86 00            stx @AreaNumber                     ; clear temp area number
000062r 3  8E 60 07         stx AreaNumber                      ; clear area number
000065r 3  AE 5C 07         ldx LevelNumber                     ; get how many levels to advance
000068r 3  F0 17            beq @LevelFound                     ; if we're on the first level, we're done
00006Ar 3               @NextArea:                              ;
00006Ar 3  20 rr rr         jsr RELOCATE_LoadAreaPointer        ; otherwise, load the area pointer
00006Dr 3  20 rr rr         jsr RELOCATE_GetAreaDataAddrs       ; then get the pointer to the area data
000070r 3  EE 60 07         inc AreaNumber                      ; advance area pointer
000073r 3  AD 10 07         lda PlayerEntranceCtrl              ; get what kind of entry this level has
000076r 3  29 04            and #%00000100                      ; check if it's a controllable area
000078r 3  F0 04            beq @AreaOK                         ; yes - advance to next level
00007Ar 3  E6 00            inc @AreaNumber                     ; yes - increment temp area number
00007Cr 3  50 EC            bvc @NextArea                       ; and check next area
00007Er 3               @AreaOK:                                ;
00007Er 3  CA               dex                                 ; decrement number of levels we need to advance
00007Fr 3  D0 E9            bne @NextArea                       ; and keep running if we haven't reached our level
000081r 3               @LevelFound:                            ;
000081r 3  18               clc                                 ;
000082r 3  AD 5C 07         lda LevelNumber                     ; get level we are starting on
000085r 3  65 00            adc @AreaNumber                     ; and add how many areas we needed to skip
000087r 3  8D 60 07         sta AreaNumber                      ; and store that as the area number
00008Ar 3  A9 00            lda #0                              ; clear sound
00008Cr 3  8D 11 40         sta SND_DELTA_REG+1                 ;
00008Fr 3  20 rr rr         jsr RELOCATE_LoadAreaPointer        ; reload pointers for this area
000092r 3  20 rr rr         jsr RELOCATE_GetAreaDataAddrs       ;
000095r 3  20 rr rr         jsr BANK_GAME_RTS                   ; load game bank
000098r 3  A9 A5            lda #$a5                            ;
00009Ar 3  4C rr rr         jmp RELOCATE_GL_ENTER               ; then start the game
00009Dr 3               ; ===========================================================================
00009Dr 3               
00009Dr 3               ; return to previous segment
00009Dr 3               .popseg
000CC7r 3               
000CC7r 2               .include "rng.asm"
000CC7r 3               ; lookup tables of RNG values for different framerules, each offset is another 2100 frames
000CC7r 3  2E BF 41 6D  resume_0: .byte $2e, $bf, $41, $6d, $1b, $0e, $4f, $c2, $ba, $4b, $e6, $b9, $78, $c2, $a0, $cc, $69, $77, $0b, $8f, $eb, $9f, $a4, $44, $d2, $e4, $e7, $22, $84, $18, $e9, $93, $7f, $7e, $a9, $8e, $0b, $68, $1e, $a8, $7c, $c0, $04, $72, $5f, $e3, $c0, $43, $59, $3d, $9a, $cf, $43, $9f, $f9, $e8, $3f, $53, $9b, $6f, $09, $8f, $56, $50, $b6, $11, $33, $d2, $9b, $31, $ee, $06, $fc, $20, $ad, $2f, $3a, $e7, $94, $bb, $37, $ef, $54, $e9, $19, $60, $53, $73, $b7, $af, $23, $e1, $dd, $ef, $d1, $db, $a5, $ce, $59
000CCBr 3  1B 0E 4F C2  
000CCFr 3  BA 4B E6 B9  
000D2Ar 3  F4 B6 A3 D1  resume_1: .byte $f4, $b6, $a3, $d1, $51, $ba, $e3, $83, $b5, $97, $63, $80, $34, $51, $f9, $15, $4d, $eb, $8d, $98, $92, $52, $bd, $5c, $c1, $93, $e8, $70, $c3, $a0, $58, $2c, $79, $38, $d0, $f9, $4b, $aa, $62, $27, $e8, $89, $6c, $b4, $69, $ce, $19, $31, $99, $6b, $69, $ec, $63, $10, $ac, $f3, $ed, $5f, $a4, $eb, $21, $20, $32, $9a, $09, $87, $ed, $09, $f8, $3b, $c5, $7a, $df, $0c, $44, $8f, $48, $0a, $95, $f8, $55, $64, $04, $c0, $bd, $60, $e1, $91, $34, $8e, $f1, $8c, $6e, $84, $92, $f6, $be, $a5, $47
000D2Er 3  51 BA E3 83  
000D32r 3  B5 97 63 80  
000D8Dr 3  A9 C9 20 0A  resume_2: .byte $a9, $c9, $20, $0a, $67, $a7, $7c, $06, $c0, $00, $af, $f3, $c4, $d5, $b8, $8d, $9f, $04, $9a, $87, $45, $6c, $f4, $d4, $64, $5a, $27, $34, $ca, $91, $8a, $0a, $87, $c4, $83, $e4, $5d, $7b, $5e, $77, $11, $08, $64, $51, $d7, $09, $99, $b7, $2a, $11, $5d, $73, $e5, $2e, $5f, $22, $92, $f9, $93, $34, $33, $3e, $9e, $3b, $65, $a4, $8a, $ad, $cf, $59, $18, $76, $26, $4c, $1e, $d0, $3c, $c4, $bc, $8f, $3b, $ba, $ac, $13, $8e, $a0, $46, $76, $5a, $d1, $b6, $4f, $d4, $5b, $31, $41, $f5, $38, $f5
000D91r 3  67 A7 7C 06  
000D95r 3  C0 00 AF F3  
000DF0r 3  40 A4 66 A8  resume_3: .byte $40, $a4, $66, $a8, $c5, $d2, $ba, $00, $ab, $2e, $68, $f2, $ad, $76, $4b, $a6, $04, $d2, $81, $b6, $61, $c8, $8f, $6d, $e6, $7c, $f7, $d4, $4d, $d0, $3b, $52, $74, $b5, $22, $17, $cb, $2f, $9a, $39, $c1, $1a, $bc, $39, $04, $95, $aa, $d4, $18, $c7, $8f, $ab, $22, $0e, $07, $c4, $49, $46, $da, $e2, $71, $7e, $fb, $0f, $77, $ab, $51, $be, $3e, $2f, $92, $82, $98, $54, $96, $cf, $ac, $d1, $97, $7e, $91, $73, $a5, $93, $f5, $61, $84, $54, $32, $cc, $55, $57, $09, $53, $15, $ad, $88, $72, $7a
000DF4r 3  C5 D2 BA 00  
000DF8r 3  AB 2E 68 F2  
000E53r 3  00 37 26 BD  resume_4: .byte $00, $37, $26, $bd, $0a, $9d, $43, $0c, $2a, $2e, $36, $15, $24, $dc, $3b, $bd, $3a, $db, $b4, $b9, $eb, $11, $66, $c5, $2f, $c8, $b8, $bd, $d9, $f3, $2f, $46, $7a, $3c, $24, $df, $70, $d9, $27, $d7, $e2, $0a, $75, $9b, $aa, $86, $99, $bb, $4c, $e4, $34, $4c, $e8, $52, $b9, $81, $6d, $b4, $fd, $8b, $17, $02, $c6, $79, $bd, $e2, $45, $e5, $a0, $9d, $a3, $6f, $d5, $cc, $ab, $6e, $d5, $58, $ee, $60, $e6, $07, $fc, $b4, $e8, $21, $09, $b8, $86, $6f, $39, $c9, $a1, $e5, $77, $2e, $63, $02, $90
000E57r 3  0A 9D 43 0C  
000E5Br 3  2A 2E 36 15  
000EB6r 3  00 7F EA EC  resume_5: .byte $00, $7f, $ea, $ec, $80, $38, $37, $0c, $7c, $72, $e6, $f1, $7e, $31, $ad, $f0, $32, $7e, $b7, $d4, $28, $81, $78, $1e, $e3, $31, $57, $14, $42, $52, $59, $e2, $92, $56, $60, $f0, $e6, $86, $13, $a4, $61, $3e, $0d, $e8, $a3, $ad, $cc, $12, $7c, $6b, $2a, $1a, $ad, $4e, $b6, $08, $ff, $39, $48, $4e, $f5, $fe, $31, $67, $52, $b5, $e7, $98, $dd, $c2, $86, $6b, $e4, $65, $86, $f0, $8c, $fa, $c1, $9c, $c5, $e1, $b7, $93, $03, $e3, $01, $11, $e3, $f7, $93, $66, $b2, $42, $5d, $74, $73, $e6, $65
000EBAr 3  80 38 37 0C  
000EBEr 3  7C 72 E6 F1  
000F19r 3  00 11 A7 97  resume_6: .byte $00, $11, $a7, $97, $95, $02, $b1, $14, $28, $2e, $8b, $da, $36, $89, $da, $8b, $46, $c8, $de, $a7, $fe, $a2, $b4, $94, $bc, $a1, $27, $6e, $f0, $b4, $07, $6f, $67, $2e, $28, $4f, $07, $35, $5d, $0b, $a5, $2a, $e7, $df, $f6, $a0, $ff, $64, $e4, $a3, $42, $82, $7c, $ea, $c5, $0a, $24, $51, $b2, $58, $da, $fb, $bd, $95, $28, $70, $6c, $53, $9c, $f9, $c1, $b5, $4f, $fd, $d1, $2d, $27, $4b, $1c, $5d, $08, $ee, $4e, $fa, $d3, $a0, $13, $61, $ee, $28, $e0, $f4, $f1, $88, $b3, $28, $b5, $e3, $45
000F1Dr 3  95 02 B1 14  
000F21r 3  28 2E 8B DA  
000F7Cr 3               
000F7Cr 3               ; ================================================================
000F7Cr 3               ;  Setup framerule RNG
000F7Cr 3               ; ----------------------------------------------------------------
000F7Cr 3               RNGQuickResume:
000F7Cr 3  AD rr rr         lda MathFrameruleDigitStart+3        ; get hundreds and thousands digits of bcd framerule value
000F7Fr 3  20 rr rr         jsr MultiplyBy10                     ;
000F82r 3  6D rr rr         adc MathFrameruleDigitStart+2        ;
000F85r 3  AA               tax                                  ; store in X
000F86r 3  BD rr rr         lda resume_0,x                       ; get rng value from lookup table for this offset
000F89r 3  8D A7 07         sta PseudoRandomBitReg+0             ;
000F8Cr 3  BD rr rr         lda resume_1,x                       ;
000F8Fr 3  8D A8 07         sta PseudoRandomBitReg+1             ;
000F92r 3  BD rr rr         lda resume_2,x                       ;
000F95r 3  8D A9 07         sta PseudoRandomBitReg+2             ;
000F98r 3  BD rr rr         lda resume_3,x                       ;
000F9Br 3  8D AA 07         sta PseudoRandomBitReg+3             ;
000F9Er 3  BD rr rr         lda resume_4,x                       ;
000FA1r 3  8D AB 07         sta PseudoRandomBitReg+4             ;
000FA4r 3  BD rr rr         lda resume_5,x                       ;
000FA7r 3  8D AC 07         sta PseudoRandomBitReg+5             ;
000FAAr 3  BD rr rr         lda resume_6,x                       ;
000FADr 3  8D AD 07         sta PseudoRandomBitReg+6             ;
000FB0r 3               @FrameruleAdjust:
000FB0r 3  AD rr rr         lda MathFrameruleDigitStart + 1      ; get ones and tens digits of bcd framerule value
000FB3r 3  20 rr rr         jsr MultiplyBy10                     ;
000FB6r 3  6D rr rr         adc MathFrameruleDigitStart + 0      ;
000FB9r 3  A8               tay                                  ; store in Y
000FBAr 3  F0 03            beq @FrameAdjust                     ; if not set, we can skip ahead
000FBCr 3  20 rr rr         jsr FRStepRNGByY                     ; otherwise we advance the RNG based on the framerule value * 21
000FBFr 3               @FrameAdjust:
000FBFr 3  AD 0B 60         lda IncrementRNG_122                 ; did we hold A for a 122 frame offset?
000FC2r 3  F0 05            beq :+                               ; branch ahead if not
000FC4r 3  A0 7A            ldy #122                             ; otherwise set Y for 122 frames
000FC6r 3  20 rr rr         jsr StepRNGByY                       ; and adjust rng for both endings patterns
000FC9r 3  AE rr rr     :   ldx SettablesPUP                     ; check if player has selected a powerup
000FCCr 3  D0 01            bne :+                               ; yes - skip ahead to adjust rng
000FCEr 3  60               rts                                  ; no - we are done!
000FCFr 3  BC rr rr     :   ldy @FramerulePowerupAdjust-1,x      ; check rng steps for current powerup value
000FD2r 3  20 rr rr         jsr StepRNGByY                       ; and adjust the rng for this value
000FD5r 3  CA               dex                                  ; decrement to next powerup value
000FD6r 3  D0 F7            bne :-                               ; and loop until we reach small mario state
000FD8r 3  60               rts                                  ; then we are done!
000FD9r 3               @FramerulePowerupAdjust:
000FD9r 3  3B               .byte 59                            ; fr pause from grabbing mushroom
000FDAr 3  3F               .byte 63                            ; fr pause from grabbing fireflower
000FDBr 3  BF               .byte 254 - 63                      ; fr pause from small fire (minus fr pause from grabbing fire)
000FDCr 3  3B               .byte 59                            ; fr pause from grabbing mushroom
000FDDr 3  3F               .byte 63                            ; fr pause from grabbing fireflower
000FDEr 3               ; ================================================================
000FDEr 3               
000FDEr 3               ; ================================================================
000FDEr 3               ;  Advance RNG by Y framerules
000FDEr 3               ; ----------------------------------------------------------------
000FDEr 3               FRStepRNGByY:
000FDEr 3  20 rr rr         jsr FRStepRNG
000FE1r 3  88               dey
000FE2r 3  D0 FA            bne FRStepRNGByY
000FE4r 3  60               rts
000FE5r 3               ; ================================================================
000FE5r 3               
000FE5r 3               ; ================================================================
000FE5r 3               ;  Advance RNG by Y frames
000FE5r 3               ; ----------------------------------------------------------------
000FE5r 3               StepRNGByY:
000FE5r 3  20 rr rr         jsr SingleStepRNG
000FE8r 3  88               dey
000FE9r 3  D0 FA            bne StepRNGByY
000FEBr 3  60               rts
000FECr 3               ; ================================================================
000FECr 3               
000FECr 3               ; ================================================================
000FECr 3               ;  Advance RNG by 21 frames
000FECr 3               ; ----------------------------------------------------------------
000FECr 3               FRStepRNG:
000FECr 3  20 rr rr         jsr SingleStepRNG
000FEFr 3  20 rr rr         jsr SingleStepRNG
000FF2r 3  20 rr rr         jsr SingleStepRNG
000FF5r 3  20 rr rr         jsr SingleStepRNG
000FF8r 3  20 rr rr         jsr SingleStepRNG
000FFBr 3  20 rr rr         jsr SingleStepRNG
000FFEr 3  20 rr rr         jsr SingleStepRNG
001001r 3  20 rr rr         jsr SingleStepRNG
001004r 3  20 rr rr         jsr SingleStepRNG
001007r 3  20 rr rr         jsr SingleStepRNG
00100Ar 3  20 rr rr         jsr SingleStepRNG
00100Dr 3  20 rr rr         jsr SingleStepRNG
001010r 3  20 rr rr         jsr SingleStepRNG
001013r 3  20 rr rr         jsr SingleStepRNG
001016r 3  20 rr rr         jsr SingleStepRNG
001019r 3  20 rr rr         jsr SingleStepRNG
00101Cr 3  20 rr rr         jsr SingleStepRNG
00101Fr 3  20 rr rr         jsr SingleStepRNG
001022r 3  20 rr rr         jsr SingleStepRNG
001025r 3  20 rr rr         jsr SingleStepRNG
001028r 3  4C rr rr         jmp SingleStepRNG
00102Br 3               ; ================================================================
00102Br 3               
00102Br 3               ; ================================================================
00102Br 3               ;  Advance RNG by a single game frame
00102Br 3               ; ----------------------------------------------------------------
00102Br 3               SingleStepRNG:
00102Br 3  48               pha
00102Cr 3  AD A7 07         lda PseudoRandomBitReg         ; get first memory location of LSFR bytes
00102Fr 3  29 02            and #%00000010                 ; mask out all but d1
001031r 3  85 00            sta $00                        ; save here
001033r 3  AD A8 07         lda PseudoRandomBitReg+1       ; get second memory location
001036r 3  29 02            and #%00000010                 ; mask out all but d1
001038r 3  45 00            eor $00                        ; perform exclusive-OR on d1 from first and second bytes
00103Ar 3  18               clc                            ; if neither or both are set, carry will be clear
00103Br 3  F0 01            beq RotPRandomBit
00103Dr 3  38               sec                            ; if one or the other is set, carry will be set
00103Er 3               RotPRandomBit:
00103Er 3  6E A7 07         ror PseudoRandomBitReg+0       ; rotate carry into d7, and rotate last bit into carry
001041r 3  6E A8 07         ror PseudoRandomBitReg+1       ; rotate carry into d7, and rotate last bit into carry
001044r 3  6E A9 07         ror PseudoRandomBitReg+2       ; rotate carry into d7, and rotate last bit into carry
001047r 3  6E AA 07         ror PseudoRandomBitReg+3       ; rotate carry into d7, and rotate last bit into carry
00104Ar 3  6E AB 07         ror PseudoRandomBitReg+4       ; rotate carry into d7, and rotate last bit into carry
00104Dr 3  6E AC 07         ror PseudoRandomBitReg+5       ; rotate carry into d7, and rotate last bit into carry
001050r 3  6E AD 07         ror PseudoRandomBitReg+6       ; rotate carry into d7, and rotate last bit into carry
001053r 3  68               pla
001054r 3  60               rts
001055r 3               ; ================================================================
001055r 3               
001055r 2               
001055r 2               ; magic save header for WRAM
001055r 2               ROMSaveHeader:
001055r 2  03 20 07 21  .byte $03, $20, $07, $21, $03
001059r 2  03           
00105Ar 2               ROMSaveHeaderEnd:
00105Ar 2               ROMSaveHeaderLen = ROMSaveHeaderEnd-ROMSaveHeader
00105Ar 2               
00105Ar 1               
00105Ar 1               .segment "INES"
000000r 1               ; MMC3 INES header
000000r 1               INES_MAPPER = 4 << 4
000000r 1               INES_BATTERY = %00000010
000000r 1               INES_VERTICAL_MIRROR = %00000001
000000r 1  4E 45 53 1A  .byte $4E,$45,$53,$1A ; NES
000004r 1  08           .byte 8               ; prg banks
000005r 1  02           .byte 2               ; chr banks
000006r 1  43           .byte INES_MAPPER | INES_BATTERY | INES_VERTICAL_MIRROR
000007r 1               
000007r 1               ;.segment "PRACTISE_PRG0"
000007r 1               ;TitleMMC3NMI:
000007r 1               ;    jsr BANK_GAME_RTS
000007r 1               ;    jmp RELOCATE_NonMaskableInterrupt
000007r 1               
000007r 1               .segment "PRACTISE_PRG2"
000000r 1               ; ================================================================
000000r 1               ;  Boot game into title screen
000000r 1               ; ----------------------------------------------------------------
000000r 1               ColdTitleReset:
000000r 1  78               sei                       ; 6502 init
000001r 1  D8               cld                       ;
000002r 1  A2 FF            ldx #$FF                  ; clear stack
000004r 1  9A               txs                       ;
000005r 1  A9 C0            lda #$c0                  ; disable APU IRQs
000007r 1  8D 17 40     	sta JOYPAD_PORT2          ;
00000Ar 1  A9 80            lda #PractiseBank         ; init greated mapper state
00000Cr 1  A2 06            ldx #$06                  ;
00000Er 1  8E 00 80         stx $8000                 ;
000011r 1  8D 01 80         sta $8001                 ;
000014r 1  20 rr rr         jsr InitializeBG_CHR      ; init CHR banks
000017r 1  20 rr rr         jsr InitializeSPR_CHR     ;
00001Ar 1  4C rr rr         jmp TitleReset2           ; and prepare the title screen
00001Dr 1               ; ----------------------------------------------------------------
00001Dr 1               
00001Dr 1               ; the following code is copied to battery backed ram
00001Dr 1               .segment "PRACTISE_WRAMCODE"
00009Dr 1               
00009Dr 1               BANK_GAME_NMI:
00009Dr 1  AD rr rr         lda IsPlaying
0000A0r 1  D0 06            bne @InGameMode
0000A2r 1  20 rr rr         jsr BANK_TITLE_RTS
0000A5r 1  4C rr rr         jmp TitleNMI
0000A8r 1               @InGameMode:
0000A8r 1  20 rr rr         jsr BANK_GAME_RTS
0000ABr 1  4C rr rr         jmp RELOCATE_NonMaskableInterrupt
0000AEr 1               
0000AEr 1               ; ================================================================
0000AEr 1               ;  Handle loading new level banks
0000AEr 1               ; ----------------------------------------------------------------
0000AEr 1               BANK_LEVELBANK_RTS:
0000AEr 1  48               pha                     ; save whatever A value we were called with
0000AFr 1  A9 06            lda #6                  ; set mmc state
0000B1r 1  8D 00 80         sta $8000               ;
0000B4r 1  A9 8A            lda #LevelsBank         ;
0000B6r 1  8D 01 80         sta $8001               ; set bank
0000B9r 1  A9 07            lda #7                  ;
0000BBr 1  8D 00 80         sta $8000               ;
0000BEr 1  A9 8B            lda #LevelsBank+1       ;
0000C0r 1  8D 01 80         sta $8001               ;
0000C3r 1  68               pla                     ; restore the A value we were called with
0000C4r 1  60               rts                     ;
0000C5r 1               ; ================================================================
0000C5r 1               
0000C5r 1               ; ================================================================
0000C5r 1               ;  Load into game bank and return control
0000C5r 1               ; ----------------------------------------------------------------
0000C5r 1               BANK_GAME_RTS:
0000C5r 1  48               pha                     ; push our current A value to not disturb it
0000C6r 1  A9 06            lda #6                  ; set mmc3 state for game mode
0000C8r 1  8D 00 80         sta $8000               ;
0000CBr 1  A9 8C            lda #GameBank           ;
0000CDr 1  8D 01 80         sta $8001               ;
0000D0r 1  A9 07            lda #7                  ;
0000D2r 1  8D 00 80         sta $8000               ;
0000D5r 1  A9 8D            lda #GameBank+1         ;
0000D7r 1  8D 01 80         sta $8001               ;
0000DAr 1  68               pla                     ; restore previous A value
0000DBr 1  60               rts                     ;
0000DCr 1               ; ================================================================
0000DCr 1               
0000DCr 1               ; ================================================================
0000DCr 1               ;  Load into title screen and return control
0000DCr 1               ; ----------------------------------------------------------------
0000DCr 1               BANK_TITLE_RTS:
0000DCr 1  48               pha                     ; push our current A value to not disturb it
0000DDr 1  A9 06            lda #6                  ; set mmc3 state for title mode
0000DFr 1  8D 00 80         sta $8000               ;
0000E2r 1  A9 80            lda #PractiseBank       ;
0000E4r 1  8D 01 80         sta $8001               ;
0000E7r 1  A9 07            lda #7                  ;
0000E9r 1  8D 00 80         sta $8000               ;
0000ECr 1  A9 81            lda #PractiseBank+1     ;
0000EEr 1  8D 01 80         sta $8001               ;
0000F1r 1  68               pla                     ; restore previous A value
0000F2r 1  60               rts                     ;
0000F3r 1               ; ================================================================
0000F3r 1               
0000F3r 1               ; interrupt handlers
0000F3r 1               .segment "PRACTISE_VEC"
000000r 1  rr rr        .word BANK_GAME_NMI
000002r 1  rr rr        .word ColdTitleReset
000004r 1  rr rr        .word IRQHandler
000004r 1               
